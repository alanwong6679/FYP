<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Planner</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="navbar.css">
    <link rel="stylesheet" href="temperature.css">
    <style>
        body { font-family: 'Roboto', sans-serif; margin: 0; padding: 0; background-color: #f4f4f9; background-image: url("index.png"); color: #333; display: flex; justify-content: center; align-items: center; min-height: 100vh; flex-direction: column; background-size: cover; background-repeat: no-repeat; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); width: 100%; max-width: 500px; margin-bottom: 60px; margin-left: 160px; }
        h1 { text-align: center; font-size: 2rem; margin-bottom: 20px; color: #007dc5; }
        form { display: flex; flex-direction: column; gap: 15px; }
        .place-container { display: flex; flex-direction: column; gap: 15px; position: relative; }
        .station-row { display: flex; align-items: center; gap: 10px; width: 100%; }
        .station-row dt { flex-shrink: 0; }
        .station-row dd { flex: 1; margin: 0; }
        .searchable-select { position: relative; width: 100%; }
        .searchable-select input { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        .searchable-select .options { position: absolute; top: 100%; left: 0; right: 0; border: 1px solid #ccc; background-color: #fff; z-index: 1000; max-height: 200px; overflow-y: auto; display: none; border-radius: 4px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        .searchable-select .options div { padding: 10px; cursor: pointer; }
        .searchable-select .options div:hover { background-color: #f0f0f0; }
        .input-change { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); cursor: pointer; padding: 5px; z-index: 10; }
        .input-change img { width: 24px; height: 24px; }
        button { padding: 10px; border: none; border-radius: 4px; background-color: #007bff; color: #fff; font-size: 16px; cursor: pointer; transition: background-color 0.3s; }
        button:hover { background-color: #0056b3; }
        .bottom-bar { background-color: rgba(51, 51, 51, 0.8); color: white; padding: 10px; position: fixed; bottom: 0; width: 100%; display: flex; align-items: center; justify-content: flex-start; z-index: 1000; }
        #temperature { font-size: 16px; margin-left: 20px; }
        #loading { text-align: center; color: #666; margin-top: 10px; }
        #route { margin-top: 20px; }
        .route-option { padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; color: #007bff; }
        .route-details { display: none; margin-left: 20px; padding: 10px; }
        .stop-list { list-style-type: none; padding: 0; }
        .stop-list li { padding: 8px 0; border-bottom: 1px solid #eee; }
        .boarding-stop { color: blue; font-weight: bold; animation: pulse 1.5s infinite; }
        .alighting-stop { color: red; font-weight: bold; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>
    <div class="container" id="main-content">
        <h1>General Planner</h1>
        <form id="routeForm">
            <div class="place-container">
                <div class="station-row">
                    <dl>
                        <dt class="starting-station">Starting Station</dt>
                    </dl>
                    <dd>
                        <div class="searchable-select" id="currentStationContainer">
                            <input type="text" id="currentStationInput" placeholder="Type to search...">
                            <div class="options" id="currentStationOptions"></div>
                        </div>
                    </dd>
                </div>
                <div class="input-change">
                    <img src="switch.png" alt="Swap Starting and Destination Stations" id="swapStations">
                </div>
                <div class="station-row">
                    <dl class="condition-item">
                        <dt class="destination-station">Destination Station</dt>
                    </dl>
                    <dd>
                        <div class="searchable-select" id="destinationStationContainer">
                            <input type="text" id="destinationStationInput" placeholder="Type to search...">
                            <div class="options" id="destinationStationOptions"></div>
                        </div>
                    </dd>
                </div>
            </div>
            <button type="submit">Find Route</button>
        </form>
        <div id="loading">Loading bus data...</div>
        <div id="route"></div>
    </div>

    <div class="bottom-bar">
        <div id="temperature">Fetching your location...</div>
    </div>

    <script src="stations.js"></script>
    <script src="navbar.js"></script>
    <script src="temperature.js"></script>
    <script src="citybusstop.js"></script>
    <script src="kmb_route.js"></script>

    <script>
        let allCitybusRoutes = [];
        let allCitybusStops = [];
        let citybusRouteStopsMap = {};
        let allKMBStops = [];
        let kmbRouteStopsMap = {};

        async function processInBatches(items, batchSize, processFn) {
            for (let i = 0; i < items.length; i += batchSize) {
                const batch = items.slice(i, i + batchSize);
                await Promise.all(batch.map(processFn));
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        }

        function updateLoadingMessage(message) {
            document.getElementById('loading').textContent = message;
        }

        function initializeData() {
            const loadingDiv = document.getElementById('loading');
            try {
                if (allCitybusRoutes.length === 0 && (!allKMBRoutes || allKMBRoutes.data.length === 0)) {
                    loadingDiv.textContent = 'No bus data available. Some features may not work.';
                } else {
                    loadingDiv.style.display = 'none';
                }
            } catch (error) {
                loadingDiv.textContent = 'Error loading bus data. Check console for details.';
                console.error('Initialization failed:', error);
            }
        }

        async function fetchCitybusAndKMBData() {
            const cachedCitybusRoutes = localStorage.getItem('allCitybusRoutes');
            const cachedCitybusStops = localStorage.getItem('allCitybusStops');
            const cachedCitybusRouteStops = localStorage.getItem('citybusRouteStopsMap');
            const cachedKMBStops = localStorage.getItem('allKMBStops');
            const cachedKMBRouteStops = localStorage.getItem('kmbRouteStopsMap');

            if (cachedCitybusRoutes && cachedCitybusStops && cachedCitybusRouteStops && cachedKMBStops && cachedKMBRouteStops) {
                allCitybusRoutes = JSON.parse(cachedCitybusRoutes);
                allCitybusStops = JSON.parse(cachedCitybusStops);
                citybusRouteStopsMap = JSON.parse(cachedCitybusRouteStops);
                allKMBStops = JSON.parse(cachedKMBStops);
                kmbRouteStopsMap = JSON.parse(cachedKMBRouteStops);
                console.log('Loaded all data from cache');
                return;
            }

            updateLoadingMessage('Loading Citybus routes...');
            try {
                const response = await fetch('https://rt.data.gov.hk/v2/transport/citybus/route/CTB');
                if (!response.ok) throw new Error('Citybus routes fetch failed');
                allCitybusRoutes = (await response.json()).data || [];
            } catch (error) {
                console.error('Error fetching Citybus routes:', error);
                allCitybusRoutes = [];
            }
            console.log('Citybus routes fetched:', allCitybusRoutes.length);

            updateLoadingMessage('Loading Citybus stops...');
            const stopsMap = {};
            const routeStopPromises = [];
            for (const route of allCitybusRoutes) {
                for (const direction of ['outbound', 'inbound']) {
                    routeStopPromises.push(async () => {
                        try {
                            const response = await fetch(`https://rt.data.gov.hk/v2/transport/citybus/route-stop/CTB/${route.route}/${direction}`);
                            if (!response.ok) throw new Error(`Failed to fetch stops for ${route.route} (${direction})`);
                            const data = await response.json();
                            if (data.data) {
                                const key = `${route.route}-${direction}`;
                                citybusRouteStopsMap[key] = data.data.map(stop => stop.stop);
                                data.data.forEach(stop => {
                                    if (!stopsMap[stop.stop]) {
                                        stopsMap[stop.stop] = { stop: stop.stop, name_en: null, lat: null, long: null, company: 'CTB' };
                                    }
                                });
                            }
                        } catch (error) {
                            console.warn(`Error fetching stops for ${route.route} (${direction}):`, error);
                        }
                    });
                }
            }
            await processInBatches(routeStopPromises, 10, fn => fn());

            const citybusStopIds = Object.keys(stopsMap);
            const citybusStopDetailsPromises = citybusStopIds.map(stopId => async () => {
                try {
                    const cachedDetails = localStorage.getItem(`CTB_${stopId}`);
                    if (cachedDetails) {
                        stopsMap[stopId] = JSON.parse(cachedDetails);
                    } else {
                        const response = await fetch(`https://rt.data.gov.hk/v2/transport/citybus/stop/${stopId}`);
                        if (!response.ok) throw new Error(`Failed to fetch CTB stop ${stopId}`);
                        const details = await response.json();
                        stopsMap[stopId].name_en = details.data.name_en || `Unknown Stop ${stopId}`;
                        stopsMap[stopId].lat = details.data.lat;
                        stopsMap[stopId].long = details.data.long;
                        localStorage.setItem(`CTB_${stopId}`, JSON.stringify(stopsMap[stopId]));
                    }
                } catch (error) {
                    console.warn(`Error fetching CTB stop details for ${stopId}:`, error);
                    stopsMap[stopId].name_en = `Unknown Stop ${stopId}`;
                }
            });
            await processInBatches(citybusStopDetailsPromises, 10, fn => fn());
            allCitybusStops = Object.values(stopsMap);
            console.log('Citybus stops fetched:', allCitybusStops.length);

            if (typeof allKMBRoutes === 'undefined') {
                console.warn('kmb_route.js not loaded or allKMBRoutes not defined');
                return;
            }

            updateLoadingMessage('Loading KMB routes...');
            const kmbRoutes = allKMBRoutes.data.map(route => ({
                route: route.route,
                direction: route.bound === 'O' ? 'outbound' : 'inbound',
                orig_en: route.orig_en,
                dest_en: route.dest_en
            }));

            updateLoadingMessage('Loading KMB stops...');
            const kmbStopsMap = {};
            const kmbRouteStopPromises = [];
            for (const route of kmbRoutes) {
                kmbRouteStopPromises.push(async () => {
                    try {
                        const response = await fetch(`https://data.etabus.gov.hk/v1/transport/kmb/route-stop/${route.route}/${route.direction}/1`);
                        if (!response.ok) throw new Error(`Failed to fetch KMB stops for ${route.route} (${route.direction})`);
                        const data = await response.json();
                        if (data.data) {
                            const key = `${route.route}-${route.direction}`;
                            kmbRouteStopsMap[key] = data.data.map(stop => stop.stop);
                            data.data.forEach(stop => {
                                if (!kmbStopsMap[stop.stop]) {
                                    kmbStopsMap[stop.stop] = { stop: stop.stop, name_en: null, lat: null, long: null, company: 'KMB' };
                                }
                            });
                        }
                    } catch (error) {
                        console.warn(`Error fetching KMB stops for ${route.route} (${route.direction}):`, error);
                    }
                });
            }
            await processInBatches(kmbRouteStopPromises, 10, fn => fn());

            const kmbStopIds = Object.keys(kmbStopsMap);
            const kmbStopDetailsPromises = kmbStopIds.map(stopId => async () => {
                try {
                    const cachedDetails = localStorage.getItem(`KMB_${stopId}`);
                    if (cachedDetails) {
                        kmbStopsMap[stopId] = JSON.parse(cachedDetails);
                    } else {
                        const response = await fetch(`https://data.etabus.gov.hk/v1/transport/kmb/stop/${stopId}`);
                        if (!response.ok) throw new Error(`Failed to fetch KMB stop ${stopId}`);
                        const details = await response.json();
                        kmbStopsMap[stopId].name_en = details.data.name_en || `Unknown Stop ${stopId}`;
                        kmbStopsMap[stopId].lat = details.data.lat;
                        kmbStopsMap[stopId].long = details.data.long;
                        localStorage.setItem(`KMB_${stopId}`, JSON.stringify(kmbStopsMap[stopId]));
                    }
                } catch (error) {
                    console.warn(`Error fetching KMB stop details for ${stopId}:`, error);
                    kmbStopsMap[stopId].name_en = `Unknown Stop ${stopId}`;
                }
            });
            await processInBatches(kmbStopDetailsPromises, 10, fn => fn());
            allKMBStops = Object.values(kmbStopsMap);
            console.log('KMB stops fetched:', allKMBStops.length);

            localStorage.setItem('allCitybusRoutes', JSON.stringify(allCitybusRoutes));
            localStorage.setItem('allCitybusStops', JSON.stringify(allCitybusStops));
            localStorage.setItem('citybusRouteStopsMap', JSON.stringify(citybusRouteStopsMap));
            localStorage.setItem('allKMBStops', JSON.stringify(allKMBStops));
            localStorage.setItem('kmbRouteStopsMap', JSON.stringify(kmbRouteStopsMap));
        }

        function getUniqueMTRStations() {
            const stationSet = new Set();
            const stations = [];
            for (let line in lines) {
                lines[line].forEach(station => {
                    if (!stationSet.has(station.value)) {
                        stationSet.add(station.value);
                        stations.push({
                            value: station.value,
                            text: station.text,
                            type: 'MTR'
                        });
                    }
                });
            }
            return stations;
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function findNearbyStops(targetStop) {
            return [...allCitybusStops, ...allKMBStops].filter(s => {
                return s.lat && s.long && 
                       haversineDistance(targetStop.lat, targetStop.long, s.lat, s.long) <= 1000;
            });
        }

        async function findBusRoutes(startStopId, endStopId) {
            updateLoadingMessage('Fetching route details...');
            const allStops = [...allCitybusStops, ...allKMBStops];
            const startStop = allStops.find(s => s.stop === startStopId);
            const endStop = allStops.find(s => s.stop === endStopId);
            const routeDiv = document.getElementById('route');
            if (!startStop || !endStop) {
                routeDiv.innerHTML = '<p>Invalid bus stops selected.</p>';
                return;
            }

            const startStops = findNearbyStops(startStop);
            const endStops = findNearbyStops(endStop);
            const startStopIds = startStops.map(s => s.stop);
            const endStopIds = endStops.map(s => s.stop);

            const directRoutes = [];

            for (const route of allCitybusRoutes) {
                for (const direction of ['outbound', 'inbound']) {
                    const key = `${route.route}-${direction}`;
                    const stops = citybusRouteStopsMap[key] || [];
                    const startMatches = stops.filter(id => startStopIds.includes(id));
                    const endMatches = stops.filter(id => endStopIds.includes(id));
                    if (startMatches.length > 0 && endMatches.length > 0) {
                        let closestStartStop = null, minStartDistance = Infinity;
                        for (const stopId of startMatches) {
                            const stop = allCitybusStops.find(s => s.stop === stopId);
                            const distance = haversineDistance(startStop.lat, startStop.long, stop.lat, stop.long);
                            if (distance < minStartDistance) {
                                minStartDistance = distance;
                                closestStartStop = stopId;
                            }
                        }
                        const startIndex = stops.indexOf(closestStartStop);
                        const possibleEndStops = endMatches.filter(id => stops.indexOf(id) > startIndex);
                        if (possibleEndStops.length > 0) {
                            let closestEndStop = null, minEndDistance = Infinity;
                            for (const stopId of possibleEndStops) {
                                const stop = allCitybusStops.find(s => s.stop === stopId);
                                const distance = haversineDistance(endStop.lat, endStop.long, stop.lat, stop.long);
                                if (distance < minEndDistance) {
                                    minEndDistance = distance;
                                    closestEndStop = stopId;
                                }
                            }
                            const stopDetails = stops.map(id => {
                                const stop = allCitybusStops.find(s => s.stop === id);
                                return { id, name: `${stop.name_en} (CTB)` };
                            });
                            directRoutes.push({
                                route: route.route,
                                direction,
                                stops: stopDetails,
                                boardingStop: closestStartStop,
                                alightingStop: closestEndStop,
                                boardingDistance: minStartDistance,
                                alightingDistance: minEndDistance,
                                company: 'CTB'
                            });
                        }
                    }
                }
            }

            const kmbRoutes = allKMBRoutes.data.map(route => ({
                route: route.route,
                direction: route.bound === 'O' ? 'outbound' : 'inbound'
            }));
            for (const route of kmbRoutes) {
                const key = `${route.route}-${route.direction}`;
                const stops = kmbRouteStopsMap[key] || [];
                const startMatches = stops.filter(id => startStopIds.includes(id));
                const endMatches = stops.filter(id => endStopIds.includes(id));
                if (startMatches.length > 0 && endMatches.length > 0) {
                    let closestStartStop = null, minStartDistance = Infinity;
                    for (const stopId of startMatches) {
                        const stop = allKMBStops.find(s => s.stop === stopId);
                        const distance = haversineDistance(startStop.lat, startStop.long, stop.lat, stop.long);
                        if (distance < minStartDistance) {
                            minStartDistance = distance;
                            closestStartStop = stopId;
                        }
                    }
                    const startIndex = stops.indexOf(closestStartStop);
                    const possibleEndStops = endMatches.filter(id => stops.indexOf(id) > startIndex);
                    if (possibleEndStops.length > 0) {
                        let closestEndStop = null, minEndDistance = Infinity;
                        for (const stopId of possibleEndStops) {
                            const stop = allKMBStops.find(s => s.stop === stopId);
                            const distance = haversineDistance(endStop.lat, endStop.long, stop.lat, stop.long);
                            if (distance < minEndDistance) {
                                minEndDistance = distance;
                                closestEndStop = stopId;
                            }
                        }
                        const stopDetails = stops.map(id => {
                            const stop = allKMBStops.find(s => s.stop === id);
                            return { id, name: `${stop.name_en} (KMB)` };
                        });
                        directRoutes.push({
                            route: route.route,
                            direction: route.direction,
                            stops: stopDetails,
                            boardingStop: closestStartStop,
                            alightingStop: closestEndStop,
                            boardingDistance: minStartDistance,
                            alightingDistance: minEndDistance,
                            company: 'KMB'
                        });
                    }
                }
            }

            if (directRoutes.length > 0) {
                routeDiv.innerHTML = '<h3>Direct Bus Routes</h3>' + renderDirectBusRoutes(directRoutes);
            } else {
                routeDiv.innerHTML = '<p>No direct bus routes found between the selected stops.</p>';
            }
            updateLoadingMessage('');
        }

        function renderDirectBusRoutes(routes) {
            return routes.map((route, index) => {
                const boardingStop = route.company === 'KMB' ? 
                    allKMBStops.find(s => s.stop === route.boardingStop) : 
                    allCitybusStops.find(s => s.stop === route.boardingStop);
                const alightingStop = route.company === 'KMB' ? 
                    allKMBStops.find(s => s.stop === route.alightingStop) : 
                    allCitybusStops.find(s => s.stop === route.alightingStop);
                const boardingName = boardingStop ? `${boardingStop.name_en} (${route.company})` : `Unknown Stop ${route.boardingStop} (${route.company})`;
                const alightingName = alightingStop ? `${alightingStop.name_en} (${route.company})` : `Unknown Stop ${route.alightingStop} (${route.company})`;
                const numStops = route.stops.findIndex(s => s.id === route.alightingStop) - 
                                route.stops.findIndex(s => s.id === route.boardingStop);
                const summary = `
                    <div 
                        class="route-option" 
                        id="route-summary-${index}" 
                        data-route="${route.route}" 
                        data-direction="${route.direction}" 
                        data-boarding-stop="${route.boardingStop}" 
                        data-company="${route.company}"
                        onclick="toggleRouteDetails('route-details-${index}', this)"
                    >
                        <strong>${route.company} Route ${route.route} (${route.direction})</strong> - ${numStops} stops<br>
                        Walk ${Math.round(route.boardingDistance)}m to ${boardingName}, alight at ${alightingName} (${Math.round(route.alightingDistance)}m)
                    </div>
                `;
                let details = `<div class="route-details" id="route-details-${index}">`;
                details += '<ul class="stop-list">';
                route.stops.forEach(stop => {
                    const className = stop.id === route.boardingStop ? 'boarding-stop' : 
                                    stop.id === route.alightingStop ? 'alighting-stop' : '';
                    const etaSpan = stop.id === route.boardingStop ? `<span id="eta-${index}"></span>` : '';
                    details += `<li class="${className}">${stop.name}${etaSpan}</li>`;
                });
                details += '</ul></div>';
                return summary + details;
            }).join('');
        }

        async function fetchETA(route, direction, stopId, detailsId, company) {
            const etaSpan = document.querySelector(`#${detailsId} .boarding-stop span`);
            if (!etaSpan) return;

            try {
                if (company === 'KMB') {
                    const response = await fetch(`https://data.etabus.gov.hk/v1/transport/kmb/eta/${stopId}/${route}/1`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    const eta = data.data.find(e => e.eta_seq === 1);
                    if (eta && eta.eta) {
                        const minutesLeft = Math.round((new Date(eta.eta) - new Date(eta.data_timestamp)) / 60000);
                        etaSpan.textContent = minutesLeft >= 0 ? ` (ETA: ${minutesLeft} min)` : ` (Due now)`;
                    } else {
                        etaSpan.textContent = ` (No ETA)`;
                    }
                } else {
                    const response = await fetch(`https://rt.data.gov.hk/v2/transport/citybus/eta/CTB/${stopId}/${route}`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    const dirMapping = { "outbound": "O", "inbound": "I" };
                    const eta = data.data.find(e => e.eta_seq === 1 && e.dir === dirMapping[direction]) || 
                                data.data.find(e => e.eta_seq === 1);
                    if (eta && eta.eta) {
                        const minutesLeft = Math.round((new Date(eta.eta) - new Date(eta.data_timestamp)) / 60000);
                        etaSpan.textContent = minutesLeft >= 0 ? ` (ETA: ${minutesLeft} min)` : ` (Due now)`;
                    } else {
                        etaSpan.textContent = ` (No ETA)`;
                    }
                }
            } catch (error) {
                etaSpan.textContent = ` (ETA unavailable)`;
                console.error(`ETA fetch failed for ${route} at ${stopId} (${company}):`, error);
            }
        }

        function toggleRouteDetails(detailsId, summaryElement) {
            const detailsDiv = document.getElementById(detailsId);
            if (detailsDiv.style.display === 'none' || !detailsDiv.style.display) {
                detailsDiv.style.display = 'block';
                const route = summaryElement.getAttribute('data-route');
                const direction = summaryElement.getAttribute('data-direction');
                const boardingStop = summaryElement.getAttribute('data-boarding-stop');
                const company = summaryElement.getAttribute('data-company');
                fetchETA(route, direction, boardingStop, detailsId, company);
            } else {
                detailsDiv.style.display = 'none';
            }
        }

        function makeSearchable(inputId, optionsId, options) {
            const input = document.getElementById(inputId);
            const optionsContainer = document.getElementById(optionsId);

            input.addEventListener('input', function() {
                const filter = input.value.toLowerCase();
                optionsContainer.innerHTML = '';
                const filteredOptions = options.filter(option => 
                    option.text.toLowerCase().includes(filter)
                );
                filteredOptions.forEach(option => {
                    const div = document.createElement('div');
                    div.textContent = option.text;
                    div.addEventListener('click', function() {
                        input.value = option.text;
                        input.dataset.value = option.value;
                        input.dataset.type = option.type;
                        optionsContainer.style.display = 'none';
                    });
                    optionsContainer.appendChild(div);
                });
                optionsContainer.style.display = filteredOptions.length > 0 ? 'block' : 'none';
            });

            input.addEventListener('focus', function() {
                optionsContainer.style.display = 'block';
            });

            document.addEventListener('click', function(event) {
                if (!input.contains(event.target) && !optionsContainer.contains(event.target)) {
                    optionsContainer.style.display = 'none';
                }
            });
        }

        document.getElementById('swapStations').addEventListener('click', function() {
            const currentInput = document.getElementById('currentStationInput');
            const destinationInput = document.getElementById('destinationStationInput');

            const tempValue = currentInput.value;
            const tempDataValue = currentInput.dataset.value;
            const tempDataType = currentInput.dataset.type;

            currentInput.value = destinationInput.value;
            currentInput.dataset.value = destinationInput.dataset.value || '';
            currentInput.dataset.type = destinationInput.dataset.type || '';

            destinationInput.value = tempValue;
            destinationInput.dataset.value = tempDataValue || '';
            destinationInput.dataset.type = tempDataType || '';
        });

        document.getElementById('routeForm').addEventListener('submit', function(e) {
            e.preventDefault();
            const currentInput = document.getElementById('currentStationInput');
            const destinationInput = document.getElementById('destinationStationInput');
            const currentType = currentInput.dataset.type;
            const destinationType = destinationInput.dataset.type;
            const currentId = currentInput.dataset.value;
            const destinationId = destinationInput.dataset.value;

            const routeDiv = document.getElementById('route');
            routeDiv.innerHTML = '';

            if (!currentId || !destinationId) {
                alert("Please select both a starting and destination station.");
                return;
            }

            if (currentType === 'MTR' && destinationType === 'MTR') {
                window.location.href = `/general_schedule.html?currentStation=${currentId}&destinationStation=${destinationId}`;
            } else if (currentType === 'Bus' && destinationType === 'MTR') {
                localStorage.setItem('allCitybusRoutes', JSON.stringify(allCitybusRoutes));
                localStorage.setItem('allCitybusStops', JSON.stringify(allCitybusStops));
                localStorage.setItem('citybusRouteStopsMap', JSON.stringify(citybusRouteStopsMap));
                localStorage.setItem('allKMBStops', JSON.stringify(allKMBStops));
                localStorage.setItem('kmbRouteStopsMap', JSON.stringify(kmbRouteStopsMap));
                window.location.href = `/general_schedule.html?startBusStop=${currentId}&destinationStation=${destinationId}`;
            } else if (currentType === 'MTR' && destinationType === 'Bus') {
                localStorage.setItem('allCitybusRoutes', JSON.stringify(allCitybusRoutes));
                localStorage.setItem('allCitybusStops', JSON.stringify(allCitybusStops));
                localStorage.setItem('citybusRouteStopsMap', JSON.stringify(citybusRouteStopsMap));
                localStorage.setItem('allKMBStops', JSON.stringify(allKMBStops));
                localStorage.setItem('kmbRouteStopsMap', JSON.stringify(kmbRouteStopsMap));
                window.location.href = `/general_schedule.html?currentStation=${currentId}&endBusStop=${destinationId}`;
            } else if (currentType === 'Bus' && destinationType === 'Bus') {
                findBusRoutes(currentId, destinationId);
            }
        });

        window.onload = async function() {
            await fetchCitybusAndKMBData();
            await initializeData();
            const mtrStations = getUniqueMTRStations();
            const busStops = [
                ...allCitybusStops.map(stop => ({
                    value: stop.stop,
                    text: `${stop.name_en} (CTB)`,
                    type: 'Bus'
                })),
                ...allKMBStops.map(stop => ({
                    value: stop.stop,
                    text: `${stop.name_en} (KMB)`,
                    type: 'Bus'
                }))
            ];
            const allOptions = [...mtrStations, ...busStops];
            makeSearchable('currentStationInput', 'currentStationOptions', allOptions);
            makeSearchable('destinationStationInput', 'destinationStationOptions', allOptions);
            getTemperature();
        };
    </script>
</body>
</html>
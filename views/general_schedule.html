<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>General Schedule</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/navbar.css">
    <link rel="stylesheet" href="/static/css/general_schedule.css">
</head>
<body>
    <header><h1>MTR & Bus Schedule</h1></header>
    <div class="container">
        <div class="sort-buttons">
            <button class="sort-button" id="sortByTime">Sort by Time</button>
            <button class="sort-button" id="sortByWalk">Sort by Walk Distance</button>
        </div>
        <div id="route-options"></div>
        <div id="schedule" class="schedule-detail"></div>
    </div>
    <div class="news-icon"></div>
    <div id="newsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="toggleModal()">×</span>
            <div class="language-switch"><button id="btnChinese">中文</button><button id="btnEnglish">English</button></div>
            <div id="newsContent">Loading...</div>
            <div class="source-reference">Source: RTHK</div>
        </div>
    </div>
    <script src="/static/js/stations.js"></script>
    <script src="/static/js/navbar.js"></script>
    <script src="/static/js/RTHK.js"></script>
    <script>
        const lineNames = {
            "AEL": "Airport Express Line <span style='display:inline-block;width:20px;height:10px;background:#00888A;border-radius:5px'></span>",
            "TCL": "Tung Chung Line <span style='display:inline-block;width:20px;height:10px;background:#F7943E;border-radius:5px'></span>",
            "TML": "Tuen Ma Line <span style='display:inline-block;width:20px;height:10px;background:#923011;border-radius:5px'></span>",
            "TKL": "Tseung Kwan O Line <span style='display:inline-block;width:20px;height:10px;background:#7D499D;border-radius:5px'></span>",
            "EAL": "East Rail Line <span style='display:inline-block;width:20px;height:10px;background:#53B7E8;border-radius:5px'></span>",
            "SIL": "South Island Line <span style='display:inline-block;width:20px;height:10px;background:#BAC429;border-radius:5px'></span>",
            "TWL": "Tsuen Wan Line <span style='display:inline-block;width:20px;height:10px;background:#ED1D24;border-radius:5px'></span>",
            "ISL": "Island Line <span style='display:inline-block;width:20px;height:10px;background:#007DC5;border-radius:5px'></span>",
            "KTL": "Kwun Tong Line <span style='display:inline-block;width:20px;height:10px;background:#00AB4E;border-radius:5px'></span>"
        };
        let allRoutes = [], allStops = [], routeStopsMap = {},
            originalContent = '', currentRoutes = [],
            sortByTimeAsc = true, sortByWalkAsc = true;

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        function findNearbyStops(station, radius = 1000) {
            return allStops.filter(s => 
                s.lat && s.long && station.lat && station.long && 
                haversineDistance(parseFloat(s.lat), parseFloat(s.long), station.lat, station.long) <= radius
            );
        }

        function findNearestMTRStation(busStop, mtrStations) {
            if (!busStop || !busStop.lat || !busStop.long) return { station: null, distance: NaN };
            let minDistance = Infinity, nearest = null;
            for (const station of mtrStations) {
                if (!station.lat || !station.long) continue;
                const distance = haversineDistance(parseFloat(busStop.lat), parseFloat(busStop.long), station.lat, station.long);
                if (!isNaN(distance) && distance < minDistance) {
                    minDistance = distance;
                    nearest = station;
                }
            }
            return { station: nearest, distance: minDistance };
        }

        function getUniqueMTRStations() {
            const stationSet = new Set();
            const stations = [];
            for (let line in lines) {
                lines[line].forEach(station => {
                    if (!stationSet.has(station.value)) {
                        stationSet.add(station.value);
                        stations.push({ value: station.value, text: station.text, lat: station.lat, long: station.long });
                    }
                });
            }
            return stations;
        }

       

        const toggleModal = () => document.getElementById('newsModal').style.display = 
            document.getElementById('newsModal').style.display === 'block' ? 'none' : 'block';

        const fetchNewsContent = () => fetch('https://programme.rthk.hk/channel/radio/trafficnews/index.php')
            .then(r => r.text())
            .then(d => {
                const doc = new DOMParser().parseFromString(d, 'text/html');
                originalContent = Array.from(doc.querySelectorAll('ul.dec > li.inner'))
                    .map(i => `<div class="news-item">${i.textContent.trim()}</div>`).join('') || 'No news.';
                document.getElementById('newsContent').innerHTML = originalContent;
                toggleModal();
            })
            .catch(e => console.error('News fetch error:', e));

        const displayRouteOptions = (best, alts, schedules, cs, ds) => {
            currentRoutes = [[best, 'Best Route'], ...alts.map((r, i) => [r, `Alternative Route ${i + 1}`])].map(([r, n]) => ({
                type: 'MTR',
                route: r,
                schedules,
                from: cs,
                to: ds,
                name: n,
                estimatedTime: r.route.reduce((t, l) => t + lines[l].length * 2, 0) + r.interchangeCount * 5,
                walkingDistance: 0
            }));
            displaySortedRoutes();
        };


       

      

        function findBusRoutesToStops(startBusStopIds, targetStopIds, provider, routes = allRoutes, stops = allStops, routeMap = routeStopsMap) {
            const directRoutes = [];
            const startStops = Array.isArray(startBusStopIds) ? startBusStopIds.map(id => stops.find(s => s.stop === id)) : [stops.find(s => s.stop === startBusStopIds)];
            const startStopIdsArray = Array.isArray(startBusStopIds) ? startBusStopIds : [startBusStopIds];
            console.log("Start Stop IDs:", startStopIdsArray);
            console.log("Target Stop IDs Sample:", targetStopIds.slice(0, 5)); // Sample for brevity
            console.log("Provider:", provider);

            const filteredRoutes = provider ? routes.filter(r => r.provider === provider) : routes;
            console.log("Filtered Routes:", filteredRoutes);

            for (const route of filteredRoutes) {
                for (const direction of ['outbound', 'inbound']) {
                    const key = `${route.route}-${direction === 'outbound' ? 'O' : 'I'}`;
                    const stopsList = routeMap[key] || [];
                    console.log(`Route ${key} Stops:`, stopsList);
                    const startMatches = stopsList.filter(id => startStopIdsArray.includes(id));
                    const endMatches = stopsList.filter(id => targetStopIds.includes(id));
                    console.log(`Start Matches for ${key}:`, startMatches);
                    console.log(`End Matches for ${key}:`, endMatches);

                    if (startMatches.length && endMatches.length) {
                        let closestStartStop = null, minStartDistance = Infinity;
                        const referenceStartStop = startStops[0];
                        for (const stopId of startMatches) {
                            const stop = stops.find(s => s.stop === stopId);
                            const distance = haversineDistance(parseFloat(referenceStartStop.lat), parseFloat(referenceStartStop.long), parseFloat(stop.lat), parseFloat(stop.long));
                            if (distance < minStartDistance) {
                                minStartDistance = distance;
                                closestStartStop = stopId;
                            }
                        }
                        const startIndex = stopsList.indexOf(closestStartStop);
                        const possibleEndStops = endMatches.filter(id => stopsList.indexOf(id) > startIndex);
                        if (possibleEndStops.length) {
                            let closestEndStop = null, minEndDistance = Infinity;
                            const referenceEndStop = stops.find(s => s.stop === targetStopIds[0]);
                            for (const stopId of possibleEndStops) {
                                const stop = stops.find(s => s.stop === stopId);
                                const distance = haversineDistance(parseFloat(referenceEndStop.lat), parseFloat(referenceEndStop.long), parseFloat(stop.lat), parseFloat(stop.long));
                                if (distance < minEndDistance) {
                                    minEndDistance = distance;
                                    closestEndStop = stopId;
                                }
                            }
                            const stopDetails = stopsList.map(id => ({
                                id,
                                name: stops.find(s => s.stop === id)?.name_en || `Stop ${id}`
                            }));
                            directRoutes.push({
                                route: route.route,
                                direction,
                                stops: stopDetails,
                                boardingStop: closestStartStop,
                                alightingStop: closestEndStop,
                                boardingDistance: minStartDistance,
                                alightingDistance: minEndDistance,
                                provider: route.provider
                            });
                        }
                    }
                }
            }
            return directRoutes;
        }

        function displaySortedRoutes() {
            const opts = document.getElementById('route-options');
            opts.innerHTML = '';
            const now = new Date();
            const currentTime = now.toTimeString().slice(0, 5);

            currentRoutes.slice(0, 7).forEach((route, i) => {
                const arrivalTime = new Date(now.getTime() + route.estimatedTime * 60000);
                const arrivalTimeStr = arrivalTime.toTimeString().slice(0, 5);
                let html = '';
                const getStopName = stopId => allStops.find(s => s.stop === stopId)?.name_en || `Stop ${stopId}`;

                if (route.type === 'MTR') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>${route.name}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            ${route.route.route.map(l => lineNames[l]).join(' → ')} (${route.route.interchangeCount} interchange${route.route.interchangeCount !== 1 ? 's' : ''})
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h2>From ${getStationFullName(route.from)} to ${getStationFullName(route.to)}</h2>
                            ${route.route.route.map(line => `
                                <h3>${lineNames[line]}</h3>
                                <div><strong>Current Time:</strong> ${route.schedules[line]?.curr_time || '-'}</div>
                                <h4>UP Trains</h4><table class="schedule-table"><tr><th>Time</th><th>Platform</th><th>Destination</th><th>Sequence</th><th>Valid</th></tr>${route.schedules[line]?.up?.length ? route.schedules[line].up.map(t => `<tr><td>${t.time}</td><td>${t.plat}</td><td>${getStationFullName(t.dest)}</td><td>${t.seq}</td><td>${t.valid}</td></tr>`).join('') : '<tr><td colspan="5">No UP trains</td></tr>'}</table>
                                <h4>DOWN Trains</h4><table class="schedule-table"><tr><th>Time</th><th>Platform</th><th>Destination</th><th>Sequence</th><th>Valid</th></tr>${route.schedules[line]?.down?.length ? route.schedules[line].down.map(t => `<tr><td>${t.time}</td><td>${t.plat}</td><td>${getStationFullName(t.dest)}</td><td>${t.seq}</td><td>${t.valid}</td></tr>`).join('') : '<tr><td colspan="5">No DOWN trains</td></tr>'}</table>
                            `).join('')}
                        </div>`;
                } else if (route.type === 'Bus') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            Bus ${route.busRoute.route} (${route.busRoute.direction}) - ${route.busRoute.stops.length - 1} stops<br>
                            Walk ${Math.round(route.boardingDistance)}m to ${getStopName(route.busRoute.boardingStop)}, alight at ${getStopName(route.busRoute.alightingStop)} (${Math.round(route.alightingDistance)}m)
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <ul class="stop-list">${route.busRoute.stops.map(s => `<li class="${s.id === route.busRoute.boardingStop ? 'boarding-stop' : s.id === route.busRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.busRoute.boardingStop ? `<span id="eta-${i}"></span>` : ''}</li>`).join('')}</ul>
                        </div>`;
                } else if (route.type === 'Bus-to-MTR') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            Bus ${route.busRoute.route} (${route.busRoute.direction}): Walk ${Math.round(route.boardingDistance)}m to ${route.boardingStopName}, alight at ${route.alightingStopName} (${route.stopCount} stops)<br>
                            Walk ${Math.round(route.walkingDistance)}m to ${getStationFullName(route.interchangeStation)}<br>
                            MTR: ${route.mtrRoute.route.map(l => lineNames[l]).join(' → ')}
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h4>Bus Segment</h4>
                            <ul class="stop-list">${route.busRoute.stops.map(s => `<li class="${s.id === route.busRoute.boardingStop ? 'boarding-stop' : s.id === route.busRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.busRoute.boardingStop ? `<span id="eta-${i}"></span>` : ''}</li>`).join('')}</ul>
                            <p>Walk ${Math.round(route.walkingDistance)}m to ${getStationFullName(route.interchangeStation)}</p>
                            <h4>MTR Segment</h4>
                            ${route.mtrRoute.route.map(line => {
                                const direction = getDirection(route.interchangeStation, route.to, line, route.schedules);
                                const trains = route.schedules[line]?.[direction] || [];
                                const nextTrain = trains.find(t => new Date(t.time) > new Date()) || trains[0];
                                return `
                                    <h5>${lineNames[line]}</h5>
                                    <table class="schedule-table">
                                        <tr><th>Next Train (mins)</th><th>Platform</th><th>Destination</th><th>Sequence</th></tr>
                                        ${nextTrain ? `<tr><td>${calculateETAMins(nextTrain.time)}</td><td>${nextTrain.plat}</td><td>${getStationFullName(nextTrain.dest)}</td><td>${nextTrain.seq}</td></tr>` : '<tr><td colspan="4">No upcoming trains</td></tr>'}
                                    </table>`;
                            }).join('')}
                        </div>`;
                    } else if (route.type === 'MTR-to-Bus') {
                        html = `
                            <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                                <strong>Route ${i + 1}</strong><br>
                                <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                                Walk ${Math.round(route.walkingDistance)}m to ${route.boardingStopName}<br>
                                Citybus ${route.busRoute.route} (${route.busRoute.direction}) to ${route.alightingStopName}
                            </div>
                            <div class="route-details" id="route-details-${i}">
                                <p>Walk ${Math.round(route.walkingDistance)}m to ${route.boardingStopName}</p>
                                <h4>Bus Segment</h4>
                                <ul class="stop-list">${route.busRoute.stops.map(s => `<li class="${s.id === route.busRoute.boardingStop ? 'boarding-stop' : s.id === route.busRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.busRoute.boardingStop ? `<span id="eta-${i}"></span>` : ''}</li>`).join('')}</ul>
                            </div>`;
                    }
                 else if (route.type === 'CTB-to-KMB') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            Citybus ${route.ctbRoute.route} (${route.ctbRoute.direction}): Walk ${Math.round(route.ctbBoardingDistance)}m to ${route.ctbBoardingStopName}, alight at ${route.ctbAlightingStopName} (${route.ctbStopCount} stops)<br>
                            Walk ${Math.round(route.walkingDistance)}m to ${route.kmbBoardingStopName}<br>
                            KMB ${route.kmbRoute.route} (${route.kmbRoute.direction}): Alight at ${route.kmbAlightingStopName} (${route.kmbStopCount} stops, ${Math.round(route.kmbAlightingDistance)}m walk)
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h4>Citybus Segment</h4>
                            <ul class="stop-list">${route.ctbRoute.stops.map(s => `<li class="${s.id === route.ctbRoute.boardingStop ? 'boarding-stop' : s.id === route.ctbRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.ctbRoute.boardingStop ? `<span id="eta-citybus-${i}"></span>` : ''}</li>`).join('')}</ul>
                            <p>Walk ${Math.round(route.walkingDistance)}m to ${route.kmbBoardingStopName}</p>
                            <h4>KMB Segment</h4>
                            <ul class="stop-list">${route.kmbRoute.stops.map(s => `<li class="${s.id === route.kmbRoute.boardingStop ? 'boarding-stop' : s.id === route.kmbRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.kmbRoute.boardingStop ? `<span id="eta-kmb-${i}"></span>` : ''}</li>`).join('')}</ul>
                        </div>`;
                }else if (route.type === 'Bus-MTR-Bus') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            ${route.startBusRoute.provider} ${route.startBusRoute.route} (${route.startBusRoute.direction}): Walk ${Math.round(route.startWalkingDistance)}m to ${route.startBoardingStopName}, alight at ${route.startAlightingStopName}<br>
                            Walk ${Math.round(route.mtrWalkingDistance)}m to ${getStationFullName(route.interchangeEndMTR)} via ${route.mtrRoute.route.map(l => lineNames[l]).join(' → ')}<br>
                            ${route.endBusRoute.provider} ${route.endBusRoute.route} (${route.endBusRoute.direction}): From ${route.endBoardingStopName} to ${route.endAlightingStopName}
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h4>${route.startBusRoute.provider} Segment</h4>
                            <ul class="stop-list">${route.startBusRoute.stops.map(s => `<li class="${s.id === route.startBusRoute.boardingStop ? 'boarding-stop' : s.id === route.startBusRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.startBusRoute.boardingStop ? `<span id="eta-start-${i}"></span>` : ''}</li>`).join('')}</ul>
                            <h4>MTR Segment</h4>
                            ${route.mtrRoute.route.map(line => `
                                <h5>${lineNames[line]}</h5>
                                <table class="schedule-table">
                                    <tr><th>Next Train (mins)</th><th>Platform</th><th>Destination</th><th>Sequence</th></tr>
                                    ${route.schedules[line]?.[getDirection(route.interchangeStartMTR, route.interchangeEndMTR, line, route.schedules)]?.find(t => new Date(t.time) > new Date()) ? `<tr><td>${calculateETAMins(route.schedules[line][getDirection(route.interchangeStartMTR, route.interchangeEndMTR, line, route.schedules)].find(t => new Date(t.time) > new Date()).time)}</td><td>${route.schedules[line][getDirection(route.interchangeStartMTR, route.interchangeEndMTR, line, route.schedules)][0].plat}</td><td>${getStationFullName(route.schedules[line][getDirection(route.interchangeStartMTR, route.interchangeEndMTR, line, route.schedules)][0].dest)}</td><td>${route.schedules[line][getDirection(route.interchangeStartMTR, route.interchangeEndMTR, line, route.schedules)][0].seq}</td></tr>` : '<tr><td colspan="4">No upcoming trains</td></tr>'}
                                </table>
                            `).join('')}
                            <h4>${route.endBusRoute.provider} Segment</h4>
                            <ul class="stop-list">${route.endBusRoute.stops.map(s => `<li class="${s.id === route.endBusRoute.boardingStop ? 'boarding-stop' : s.id === route.endBusRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.endBusRoute.boardingStop ? `<span id="eta-end-${i}"></span>` : ''}</li>`).join('')}</ul>
                        </div>`;
                }
                opts.innerHTML += html;
            });
        }

        function toggleRouteDetails(id, el) {
            const details = document.getElementById(id);
            details.style.display = details.style.display === 'none' ? 'block' : 'none';
            if (details.style.display === 'block' && currentRoutes) {
                const routeIndex = parseInt(id.split('-')[2]);
                const route = currentRoutes[routeIndex];
                if (route.type === 'Bus') {
                    fetchETA(route.busRoute.route, route.busRoute.direction, route.busRoute.boardingStop, id, route.busRoute.provider === 'kmb' ? 'KMB' : 'Citybus', routeIndex);
                } else if (route.type === 'CTB-to-KMB') {
                    fetchETA(route.ctbRoute.route, route.ctbRoute.direction, route.ctbRoute.boardingStop, id, 'Citybus', routeIndex);
                    fetchETA(route.kmbRoute.route, route.kmbRoute.direction, route.kmbRoute.boardingStop, id, 'KMB', routeIndex);
                } else if (route.type === 'Bus-to-MTR') {
                    fetchETA(route.busRoute.route, route.busRoute.direction, route.busRoute.boardingStop, id, route.busRoute.provider === 'kmb' ? 'KMB' : 'Citybus', routeIndex);
                } else if (route.type === 'Bus-MTR-Bus') {
                    fetchETA(route.startBusRoute.route, route.startBusRoute.direction, route.startBusRoute.boardingStop, id, route.startBusRoute.provider === 'kmb' ? 'KMB' : 'Citybus', `start-${routeIndex}`);
                    fetchETA(route.endBusRoute.route, route.endBusRoute.direction, route.endBusRoute.boardingStop, id, route.endBusRoute.provider === 'kmb' ? 'KMB' : 'Citybus', `end-${routeIndex}`);
                }
            }
        }
        async function fetchETA(route, dir, stop, detailsId, provider, index) {
            const span = document.querySelector(`#${detailsId} .boarding-stop span[id='eta-${provider.toLowerCase()}-${index}']`) || 
                         document.querySelector(`#${detailsId} .boarding-stop span[id='eta-${index}']`);
            if (!span) return;

            try {
                const url = provider === 'KMB' ? `https://data.etabus.gov.hk/v1/transport/kmb/eta/${stop}/${route}/1` : 
                           `https://rt.data.gov.hk/v2/transport/citybus/eta/CTB/${stop}/${route}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const { data } = await response.json();
                const dirMapping = { "outbound": "O", "inbound": "I" };
                const direction = dirMapping[dir] || dir;
                let eta = provider === 'KMB' ? data.find(e => e.seq === 1 && e.dir === direction) || data.find(e => e.seq === 1) :
                          data.data.find(e => e.eta_seq === 1 && e.dir === direction) || data.data.find(e => e.eta_seq === 1);
                if (eta?.eta) {
                    const mins = Math.round((new Date(eta.eta) - new Date(provider === 'KMB' ? eta.generated_timestamp : eta.data_timestamp)) / 60000);
                    span.textContent = mins >= 0 ? ` (ETA: ${mins} min)` : ` (Due now)`;
                } else {
                    span.textContent = ` (No ETA data)`;
                }
            } catch (e) {
                span.textContent = ` (ETA unavailable)`;
                console.error(`ETA fetch error for ${provider} route ${route} at stop ${stop}:`, e);
            }
        }

        function calculateETAMins(trainTime) {
            const now = new Date();
            const trainDate = new Date(trainTime);
            const diffMs = trainDate - now;
            const mins = Math.round(diffMs / 60000);
            return mins >= 0 ? mins : 'Due';
        }

        function getDirection(currentStation, destinationStation, line, schedules) {
            const lineStations = lines[line];
            const currentIndex = lineStations.findIndex(s => s.value === currentStation);
            const destIndex = lineStations.findIndex(s => s.value === destinationStation);
            return destIndex > currentIndex ? 'up' : 'down';
        }

        const getStationFullName = code => Object.values(lines).flat().find(s => s.value === code)?.text || code;

        function setupSortButtons() {
            const sortByTimeBtn = document.getElementById('sortByTime');
            const sortByWalkBtn = document.getElementById('sortByWalk');

            sortByTimeBtn.addEventListener('click', () => {
                sortByTimeAsc = !sortByTimeAsc;
                currentRoutes.sort((a, b) => sortByTimeAsc ? a.estimatedTime - b.estimatedTime : b.estimatedTime - a.estimatedTime);
                displaySortedRoutes();
                sortByTimeBtn.classList.add('active');
                sortByWalkBtn.classList.remove('active');
                sortByTimeBtn.textContent = `Sort by Time (${sortByTimeAsc ? 'Fastest' : 'Slowest'})`;
            });

            sortByWalkBtn.addEventListener('click', () => {
                sortByWalkAsc = !sortByWalkAsc;
                currentRoutes.sort((a, b) => sortByWalkAsc ? a.walkingDistance - b.walkingDistance : b.walkingDistance - a.walkingDistance);
                displaySortedRoutes();
                sortByWalkBtn.classList.add('active');
                sortByTimeBtn.classList.remove('active');
                sortByWalkBtn.textContent = `Sort by Walk Distance (${sortByWalkAsc ? 'Shortest' : 'Longest'})`;
            });
        }
///////////////////MAIN CORE FUNCTION///////////////////////
window.onload = () => {
    const params = new URLSearchParams(window.location.search);
    const [cs, ds, sbs, ebs, startCompany, endCompany] = [
        params.get('currentStation'),
        params.get('destinationStation'),
        params.get('startBusStop'),
        params.get('endBusStop'),
        params.get('startCompany'),
        params.get('endCompany')
    ];

    allRoutes = [...(JSON.parse(localStorage.getItem('kmb_allRoutes') || '[]')), 
                 ...(JSON.parse(localStorage.getItem('citybus_allRoutes') || '[]'))];
    allStops = [...(JSON.parse(localStorage.getItem('kmb_allStops') || '[]')), 
                ...(JSON.parse(localStorage.getItem('citybus_allStops') || '[]'))];
    routeStopsMap = {...JSON.parse(localStorage.getItem('kmb_routeStopsMap') || '{}'), 
                     ...JSON.parse(localStorage.getItem('citybus_routeStopsMap') || '{}')};

    if (!allStops.length) {
        document.getElementById('schedule').innerHTML = '<div class="error">Bus data not loaded.</div>';
        return;
    }

    calculateRoute(
        cs ? 'MTR' : 'Bus',
        cs || sbs,
        startCompany,
        ds ? 'MTR' : 'Bus',
        ds || ebs,
        endCompany
    );

    document.querySelector('.news-icon').onclick = fetchNewsContent;
    document.getElementById('btnChinese').onclick = () => document.getElementById('newsContent').innerHTML = originalContent || 'No news.';
    setupSortButtons();
};
    </script>
</body>
</html>
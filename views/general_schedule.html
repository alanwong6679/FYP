<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>General Schedule</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/navbar.css">
    <style>
        body { 
            font-family: 'Roboto', sans-serif; 
            margin: 0; 
            padding: 0; 
            background: #f4f4f9; 
            color: #333; 
        }
        header { 
            background: #007dc5; 
            padding: 15px; 
            color: #fff; 
            text-align: center; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
        }
        .container { 
            max-width: 1200px; 
            margin: 20px auto; 
            padding: 20px; 
            background: #fff; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
            border-radius: 8px; 
        }
        h1, h2, h3 { 
            color: #007dc5; 
            text-align: center; 
        }
        .sort-buttons { 
            display: flex; 
            justify-content: center; 
            gap: 15px; 
            margin-bottom: 20px; 
        }
        .sort-button { 
            padding: 10px 20px; 
            border: none; 
            border-radius: 5px; 
            background: #007bff; 
            color: #fff; 
            font-size: 16px; 
            cursor: pointer; 
            transition: background 0.3s, transform 0.1s; 
        }
        .sort-button:hover { 
            background: #0056b3; 
        }
        .sort-button.active { 
            background: #28a745; 
            transform: scale(1.05); 
        }
        .route-option { 
            border: 1px solid #ccc; 
            padding: 15px; 
            margin: 10px 0; 
            cursor: pointer; 
            border-radius: 8px; 
            transition: background 0.3s, box-shadow 0.2s; 
            background: #fafafa; 
        }
        .route-option:hover { 
            background: #f0f0f0; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
        }
        .schedule-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 10px; 
        }
        .schedule-table th, .schedule-table td { 
            padding: 10px; 
            border: 1px solid #ddd; 
            text-align: left; 
        }
        .schedule-table th { 
            background: #f2f2f2; 
            font-weight: 500; 
        }
        .route-details { 
            display: none; 
            margin-left: 20px; 
            padding: 10px; 
            background: #f9f9f9; 
            border-radius: 5px; 
        }
        .stop-list { 
            list-style: none; 
            padding: 0; 
        }
        .stop-list li { 
            padding: 8px 0; 
            border-bottom: 1px solid #eee; 
        }
        .boarding-stop, .alighting-stop { 
            font-weight: bold; 
            animation: pulse 1.5s infinite; 
        }
        .boarding-stop { color: #007bff; }
        .alighting-stop { color: #dc3545; }
        @keyframes pulse { 
            0%, 100% { opacity: 1; } 
            50% { opacity: 0.5; } 
        }
        .modal { 
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0; 
            top: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.4); 
        }
        .modal-content { 
            background: #fff; 
            margin: 10% auto; 
            padding: 20px; 
            border: 1px solid #888; 
            width: 80%; 
            max-width: 600px; 
            border-radius: 8px; 
            max-height: 70vh; 
            overflow-y: auto; 
        }
        .news-item { 
            margin-bottom: 10px; 
            padding: 10px; 
            border-bottom: 1px solid #ccc; 
        }
        .close { 
            color: #aaa; 
            float: right; 
            font-size: 28px; 
            font-weight: bold; 
            cursor: pointer; 
        }
        .close:hover { 
            color: #000; 
        }
        .language-switch { 
            position: absolute; 
            top: 10px; 
            right: 10px; 
            display: flex; 
            gap: 10px; 
        }
        .source-reference { 
            margin-top: 20px; 
            font-size: 12px; 
            color: gray; 
            text-align: center; 
        }
        .time-display { 
            font-size: 20px; 
            font-weight: bold; 
            color: #007dc5; 
            margin: 5px 0; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }
        .eta { 
            font-size: 16px; 
            color: #555; 
            font-weight: normal; 
        }
    </style>
</head>
<body>
    <header><h1>MTR & Bus Schedule</h1></header>
    <div class="container">
        <div class="sort-buttons">
            <button class="sort-button" id="sortByTime">Sort by Time</button>
            <button class="sort-button" id="sortByWalk">Sort by Walk Distance</button>
        </div>
        <div id="route-options"></div>
        <div id="schedule" class="schedule-detail"></div>
    </div>
    <div class="news-icon"></div>
    <div id="newsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="toggleModal()">×</span>
            <div class="language-switch"><button id="btnChinese">中文</button><button id="btnEnglish">English</button></div>
            <div id="newsContent">Loading...</div>
            <div class="source-reference">Source: RTHK</div>
        </div>
    </div>
    <script src="/static/js/stations.js"></script>
    <script src="/static/js/navbar.js"></script>
    <script src="/static/js/RTHK.js"></script>
    <script>
        const lineNames = {
            "AEL": "Airport Express Line <span style='display:inline-block;width:20px;height:10px;background:#00888A;border-radius:5px'></span>",
            "TCL": "Tung Chung Line <span style='display:inline-block;width:20px;height:10px;background:#F7943E;border-radius:5px'></span>",
            "TML": "Tuen Ma Line <span style='display:inline-block;width:20px;height:10px;background:#923011;border-radius:5px'></span>",
            "TKL": "Tseung Kwan O Line <span style='display:inline-block;width:20px;height:10px;background:#7D499D;border-radius:5px'></span>",
            "EAL": "East Rail Line <span style='display:inline-block;width:20px;height:10px;background:#53B7E8;border-radius:5px'></span>",
            "SIL": "South Island Line <span style='display:inline-block;width:20px;height:10px;background:#BAC429;border-radius:5px'></span>",
            "TWL": "Tsuen Wan Line <span style='display:inline-block;width:20px;height:10px;background:#ED1D24;border-radius:5px'></span>",
            "ISL": "Island Line <span style='display:inline-block;width:20px;height:10px;background:#007DC5;border-radius:5px'></span>",
            "KTL": "Kwun Tong Line <span style='display:inline-block;width:20px;height:10px;background:#00AB4E;border-radius:5px'></span>"
        };
        let allRoutes = [],
    allStops = [],
    routeStopsMap = {},
    originalContent = '',
    currentRoutes = [],
    sortByTimeAsc = true,
    sortByWalkAsc = true;

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        function findNearbyStops(station) {
            return allStops.filter(s => haversineDistance(parseFloat(s.lat), parseFloat(s.long), station.lat, station.long) <= 1000);
        }

        function findNearestMTRStation(busStop, mtrStations) {
            if (!busStop || !busStop.lat || !busStop.long) return { station: null, distance: NaN };
            let minDistance = Infinity;
            let nearest = null;
            for (const station of mtrStations) {
                if (!station.lat || !station.long) continue;
                const distance = haversineDistance(parseFloat(busStop.lat), parseFloat(busStop.long), parseFloat(station.lat), parseFloat(station.long));
                if (!isNaN(distance) && distance < minDistance) {
                    minDistance = distance;
                    nearest = station;
                }
            }
            return { station: nearest, distance: minDistance };
        }

        function getUniqueMTRStations() {
            const stationSet = new Set();
            const stations = [];
            for (let line in lines) {
                lines[line].forEach(station => {
                    if (!stationSet.has(station.value)) {
                        stationSet.add(station.value);
                        stations.push({ value: station.value, text: station.text, lat: station.lat, long: station.long });
                    }
                });
            }
            return stations;
        }window.onload = () => {
            const params = new URLSearchParams(window.location.search);
            const cs = params.get('currentStation');
            const ds = params.get('destinationStation');
            const sbs = params.get('startBusStop');
            const ebs = params.get('endBusStop');
            const company = params.get('company')?.toLowerCase() || 'citybus'; // Default to 'citybus'
        
            // Load company-specific bus data from localStorage
            allRoutes = JSON.parse(localStorage.getItem(`${company}_allRoutes`)) || [];
            allStops = JSON.parse(localStorage.getItem(`${company}_allStops`)) || [];
            routeStopsMap = JSON.parse(localStorage.getItem(`${company}_routeStopsMap`)) || {};
        
            console.log('Company:', company);
            console.log('All Routes:', allRoutes);
            console.log('All Stops:', allStops.map(s => s.stop)); // Log stop IDs for debugging
            console.log('Route Stops Map:', routeStopsMap);
        
            const mtrStations = getUniqueMTRStations();
        
            if (!allRoutes.length || !allStops.length) {
                document.getElementById('schedule').innerHTML = '<div class="error">Bus data not loaded. Please try again.</div>';
                return;
            }
        
            if (cs && ds) fetchSchedule(cs, ds); // MTR-to-MTR
            else if (sbs && ebs) fetchBusRoutes(sbs, ebs); // Bus-to-Bus
            else if (sbs && ds) fetchBusToMTR(sbs, ds, mtrStations); // Bus-to-MTR
            else if (cs && ebs) fetchMTRToBus(cs, ebs, mtrStations); // MTR-to-Bus
            else document.getElementById('schedule').innerHTML = '<div class="error">Invalid parameters.</div>';
        
            document.querySelector('.news-icon').onclick = fetchNewsContent;
            document.getElementById('btnChinese').onclick = () => document.getElementById('newsContent').innerHTML = originalContent || 'No news.';
            setupSortButtons();
        };

        const toggleModal = () => document.getElementById('newsModal').style.display = document.getElementById('newsModal').style.display === 'block' ? 'none' : 'block';

        const fetchNewsContent = () => fetch('https://programme.rthk.hk/channel/radio/trafficnews/index.php')
            .then(r => r.text())
            .then(d => {
                const doc = new DOMParser().parseFromString(d, 'text/html');
                originalContent = Array.from(doc.querySelectorAll('ul.dec > li.inner')).map(i => `<div class="news-item">${i.textContent.trim()}</div>`).join('') || 'No news.';
                document.getElementById('newsContent').innerHTML = originalContent;
                toggleModal();
            })
            .catch(e => console.error('News fetch error:', e));

        const fetchSchedule = async (cs, ds) => {
            try {
                const { error, schedules, bestRoute, alternativeRoutes } = await (await fetch('/fetch_schedule', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ currentStation: cs, destinationStation: ds }) })).json();
                document.getElementById('schedule').innerHTML = error ? `<div class="error">${error}</div>` : '';
                if (!error) displayRouteOptions(bestRoute, alternativeRoutes, schedules, cs, ds);
            } catch (e) {
                document.getElementById('schedule').innerHTML = '<div class="error">Fetch failed.</div>';
                console.error('Schedule error:', e);
            }
        };

        const displayRouteOptions = (best, alts, schedules, cs, ds) => {
            const opts = document.getElementById('route-options');
            opts.innerHTML = '';
            currentRoutes = [[best, 'Best Route'], ...alts.map((r, i) => [r, `Alternative Route ${i + 1}`])].map(([r, n]) => ({
                type: 'MTR',
                route: r,
                schedules,
                from: cs,
                to: ds,
                name: n,
                estimatedTime: r.route.reduce((t, l) => t + lines[l].length * 2, 0) + r.interchangeCount * 5,
                walkingDistance: 0
            }));
            displaySortedRoutes();
        };

        const fetchBusRoutes = (start, end) => {
            const [ss, es] = [allStops.find(s => s.stop === start), allStops.find(s => s.stop === end)];
            if (!ss || !es) return document.getElementById('schedule').innerHTML = '<p>Invalid bus stops.</p>';
            const [startStops, endStops] = [findNearbyStops(ss), findNearbyStops(es)], [startIds, endIds] = [startStops.map(s => s.stop), endStops.map(s => s.stop)], routes = [];
            allRoutes.forEach(r => ['outbound', 'inbound'].forEach(d => {
                const key = `${r.route}-${d}`, stops = routeStopsMap[key] || [], sm = stops.filter(id => startIds.includes(id)), em = stops.filter(id => endIds.includes(id));
                if (sm.length && em.length) {
                    const cs = sm.reduce((a, id) => { const s = allStops.find(s => s.stop === id), d = haversineDistance(parseFloat(ss.lat), parseFloat(ss.long), parseFloat(s.lat), parseFloat(s.long)); return d < a[1] ? [id, d] : a; }, ['', Infinity])[0];
                    const si = stops.indexOf(cs), pes = em.filter(id => stops.indexOf(id) > si);
                    if (pes.length) {
                        const ce = pes.reduce((a, id) => { const s = allStops.find(s => s.stop === id), d = haversineDistance(parseFloat(es.lat), parseFloat(es.long), parseFloat(s.lat), parseFloat(s.long)); return d < a[1] ? [id, d] : a; }, ['', Infinity])[0];
                        routes.push({
                            type: 'Bus',
                            busRoute: { route: r.route, direction: d, stops: stops.map(id => ({ id, name: allStops.find(s => s.stop === id)?.name_en || `Stop ${id}` })), boardingStop: cs, alightingStop: ce },
                            boardingDistance: haversineDistance(parseFloat(ss.lat), parseFloat(ss.long), parseFloat(allStops.find(s => s.stop === cs).lat), parseFloat(allStops.find(s => s.stop === cs).long)),
                            alightingDistance: haversineDistance(parseFloat(es.lat), parseFloat(es.long), parseFloat(allStops.find(s => s.stop === ce).lat), parseFloat(allStops.find(s => s.stop === ce).long)),
                            estimatedTime: (stops.indexOf(ce) - stops.indexOf(cs)) * 2,
                            walkingDistance: haversineDistance(parseFloat(ss.lat), parseFloat(ss.long), parseFloat(allStops.find(s => s.stop === cs).lat), parseFloat(allStops.find(s => s.stop === cs).long)) + haversineDistance(parseFloat(es.lat), parseFloat(es.long), parseFloat(allStops.find(s => s.stop === ce).lat), parseFloat(allStops.find(s => s.stop === ce).long))
                        });
                    }
                }
            }));
            currentRoutes = routes;
            displaySortedRoutes();
        };

        async function fetchBusToMTR(startBusStop, destinationStation, mtrStations) {
            const startStop = allStops.find(s => s.stop === startBusStop);
            if (!startStop) {
                document.getElementById('schedule').innerHTML = '<p>Invalid starting bus stop.</p>';
                return;
            }
            const company = new URLSearchParams(window.location.search).get('company') || 'Citybus';
            localStorage.setItem('company', company);
            const nearbyStartStops = findNearbyStops(startStop, 500);
            const nearbyStartStopIds = nearbyStartStops.map(s => s.stop);
            const busRoutes = findBusRoutesToStops(nearbyStartStopIds, allStops.map(s => s.stop));

            if (!busRoutes.length) {
                document.getElementById('schedule').innerHTML = '<p>No bus routes found.</p>';
                return;
            }

            const routes = [];
            for (const busRoute of busRoutes) {
                const boardingStop = allStops.find(s => s.stop === busRoute.boardingStop);
                const alightingStop = allStops.find(s => s.stop === busRoute.alightingStop);
                const stopIndexStart = busRoute.stops.findIndex(s => s.id === busRoute.boardingStop);
                const stopIndexEnd = busRoute.stops.findIndex(s => s.id === busRoute.alightingStop);
                const stopCount = stopIndexEnd >= stopIndexStart ? stopIndexEnd - stopIndexStart : 0;

                const busDetails = {
                    busRoute,
                    boardingStopName: boardingStop?.name_en || `Stop ${busRoute.boardingStop}`,
                    alightingStopName: alightingStop?.name_en || `Stop ${busRoute.alightingStop}`,
                    boardingDistance: busRoute.boardingDistance,
                    stopCount
                };

                const nearbyMTRs = mtrStations
                    .map(station => ({
                        station,
                        distance: haversineDistance(parseFloat(alightingStop.lat), parseFloat(alightingStop.long), parseFloat(station.lat), parseFloat(station.long))
                    }))
                    .filter(m => !isNaN(m.distance))
                    .sort((a, b) => a.distance - b.distance)
                    .slice(0, 3);

                for (const { station, distance } of nearbyMTRs) {
                    const interchangeStation = station.value;
                    const walkingDistanceToMTR = distance;

                    const mtrResponse = await fetch('/fetch_schedule', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ currentStation: interchangeStation, destinationStation })
                    }).then(res => res.json()).catch(err => ({ error: 'MTR schedule unavailable' }));

                    if (!mtrResponse.error) {
                        const busTime = stopCount * 2;
                        const walkingTime = walkingDistanceToMTR / 5000 * 60;
                        const mtrTime = mtrResponse.bestRoute.route.reduce((total, line) => lines[line].length * 2, 0) + mtrResponse.bestRoute.interchangeCount * 5;

                        routes.push({
                            type: 'Bus-to-MTR',
                            ...busDetails,
                            mtrRoute: mtrResponse.bestRoute,
                            interchangeStation,
                            walkingDistance: walkingDistanceToMTR,
                            schedules: mtrResponse.schedules,
                            estimatedTime: Math.round(busTime + walkingTime + mtrTime)
                        });
                    }
                }
            }
            currentRoutes = routes;
            displaySortedRoutes();
        }

        async function fetchMTRToBus(currentStation, endBusStop, mtrStations) {
            const endStop = allStops.find(s => s.stop === endBusStop);
            if (!endStop || isNaN(parseFloat(endStop.lat)) || isNaN(parseFloat(endStop.long))) {
                document.getElementById('schedule').innerHTML = '<p>Invalid ending bus stop.</p>';
                return;
            }

            const nearbyMTRs = mtrStations
                .map(station => ({
                    station,
                    distance: haversineDistance(parseFloat(endStop.lat), parseFloat(endStop.long), parseFloat(station.lat), parseFloat(station.long))
                }))
                .filter(m => !isNaN(m.distance))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 3);

            const routes = [];
            for (const { station, distance } of nearbyMTRs) {
                const destinationMTRStation = station.value;
                const walkingDistance = distance;

                const mtrResponse = await fetch('/fetch_schedule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ currentStation, destinationStation: destinationMTRStation })
                }).then(res => res.json()).catch(err => ({ error: 'MTR schedule unavailable' }));

                if (!mtrResponse.error) {
                    const mtrTime = mtrResponse.bestRoute.route.reduce((total, line) => lines[line].length * 2, 0) + mtrResponse.bestRoute.interchangeCount * 5;
                    const walkingTime = walkingDistance / 5000 * 60;
                    routes.push({
                        type: 'MTR-to-Bus',
                        mtrRoute: mtrResponse.bestRoute,
                        schedules: mtrResponse.schedules,
                        from: currentStation,
                        to: destinationMTRStation,
                        walkingDistance: walkingDistance,
                        endStopName: endStop.name_en,
                        estimatedTime: Math.round(mtrTime + walkingTime)
                    });

                    if (mtrResponse.alternativeRoutes && mtrResponse.alternativeRoutes.length > 0) {
                        mtrResponse.alternativeRoutes.forEach(altRoute => {
                            const altMtrTime = altRoute.route.reduce((total, line) => lines[line].length * 2, 0) + altRoute.interchangeCount * 5;
                            routes.push({
                                type: 'MTR-to-Bus',
                                mtrRoute: altRoute,
                                schedules: mtrResponse.schedules,
                                from: currentStation,
                                to: destinationMTRStation,
                                walkingDistance: walkingDistance,
                                endStopName: endStop.name_en,
                                estimatedTime: Math.round(altMtrTime + walkingTime)
                            });
                        });
                    }
                }
            }
            currentRoutes = routes;
            displaySortedRoutes();
        }

        function findBusRoutesToStops(startBusStopIds, targetStopIds) {
            const directRoutes = [];
            const startStops = Array.isArray(startBusStopIds) ? startBusStopIds.map(id => allStops.find(s => s.stop === id)) : [allStops.find(s => s.stop === startBusStopIds)];
            const startStopIdsArray = Array.isArray(startBusStopIds) ? startBusStopIds : [startBusStopIds];

            for (const route of allRoutes) {
                for (const direction of ['outbound', 'inbound']) {
                    const key = `${route.route}-${direction}`;
                    const stops = routeStopsMap[key] || [];
                    const startMatches = stops.filter(id => startStopIdsArray.includes(id));
                    const endMatches = stops.filter(id => targetStopIds.includes(id));
                    if (startMatches.length > 0 && endMatches.length > 0) {
                        let closestStartStop = null, minStartDistance = Infinity;
                        const referenceStartStop = startStops[0];
                        for (const stopId of startMatches) {
                            const stop = allStops.find(s => s.stop === stopId);
                            const distance = haversineDistance(parseFloat(referenceStartStop.lat), parseFloat(referenceStartStop.long), parseFloat(stop.lat), parseFloat(stop.long));
                            if (distance < minStartDistance) {
                                minStartDistance = distance;
                                closestStartStop = stopId;
                            }
                        }
                        const startIndex = stops.indexOf(closestStartStop);
                        const possibleEndStops = endMatches.filter(id => stops.indexOf(id) > startIndex);
                        if (possibleEndStops.length > 0) {
                            let closestEndStop = null, minEndDistance = Infinity;
                            const referenceEndStop = allStops.find(s => s.stop === targetStopIds[0]);
                            for (const stopId of possibleEndStops) {
                                const stop = allStops.find(s => s.stop === stopId);
                                const distance = haversineDistance(parseFloat(referenceEndStop.lat), parseFloat(referenceEndStop.long), parseFloat(stop.lat), parseFloat(stop.long));
                                if (distance < minEndDistance) {
                                    minEndDistance = distance;
                                    closestEndStop = stopId;
                                }
                            }
                            const stopDetails = stops.map(id => {
                                const stop = allStops.find(s => s.stop === id);
                                return { id, name: stop ? stop.name_en : `Stop ${id}` };
                            });
                            directRoutes.push({
                                route: route.route,
                                direction,
                                stops: stopDetails,
                                boardingStop: closestStartStop,
                                alightingStop: closestEndStop,
                                boardingDistance: minStartDistance,
                                alightingDistance: minEndDistance
                            });
                        }
                    }
                }
            }
            return directRoutes;
        }

        function displaySortedRoutes() {
            const opts = document.getElementById('route-options');
            opts.innerHTML = '';
            const now = new Date();
            const currentTime = now.toTimeString().slice(0, 5);

            currentRoutes.slice(0, 7).forEach((route, i) => {
                const arrivalTime = new Date(now.getTime() + route.estimatedTime * 60000);
                const arrivalTimeStr = arrivalTime.toTimeString().slice(0, 5);
                let html = '';

                if (route.type === 'MTR') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>${route.name}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            ${route.route.route.map(l => lineNames[l]).join(' → ')} (${route.route.interchangeCount} interchange${route.route.interchangeCount !== 1 ? 's' : ''})
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h2>From ${getStationFullName(route.from)} to ${getStationFullName(route.to)}</h2>
                            ${route.route.route.map(line => `
                                <h3>${lineNames[line]}</h3>
                                <div><strong>Current Time:</strong> ${route.schedules[line]?.curr_time || '-'}</div>
                                <h4>UP Trains</h4><table class="schedule-table"><tr><th>Time</th><th>Platform</th><th>Destination</th><th>Sequence</th><th>Valid</th></tr>${route.schedules[line]?.up?.length ? route.schedules[line].up.map(t => `<tr><td>${t.time}</td><td>${t.plat}</td><td>${getStationFullName(t.dest)}</td><td>${t.seq}</td><td>${t.valid}</td></tr>`).join('') : '<tr><td colspan="5">No UP trains</td></tr>'}</table>
                                <h4>DOWN Trains</h4><table class="schedule-table"><tr><th>Time</th><th>Platform</th><th>Destination</th><th>Sequence</th><th>Valid</th></tr>${route.schedules[line]?.down?.length ? route.schedules[line].down.map(t => `<tr><td>${t.time}</td><td>${t.plat}</td><td>${getStationFullName(t.dest)}</td><td>${t.seq}</td><td>${t.valid}</td></tr>`).join('') : '<tr><td colspan="5">No DOWN trains</td></tr>'}</table>
                            `).join('')}
                        </div>
                    `;
                } else if (route.type === 'Bus') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            Bus ${route.busRoute.route} (${route.busRoute.direction}) - ${route.busRoute.stops.length - 1} stops<br>
                            Walk ${Math.round(route.boardingDistance)}m to ${route.busRoute.stops.find(s => s.id === route.busRoute.boardingStop).name}, alight at ${route.busRoute.stops.find(s => s.id === route.busRoute.alightingStop).name} (${Math.round(route.alightingDistance)}m)
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <ul class="stop-list">${route.busRoute.stops.map(s => `<li class="${s.id === route.busRoute.boardingStop ? 'boarding-stop' : s.id === route.busRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.busRoute.boardingStop ? `<span id="eta-${i}"></span>` : ''}</li>`).join('')}</ul>
                        </div>
                    `;
                } else if (route.type === 'Bus-to-MTR') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            Bus ${route.busRoute.route} (${route.busRoute.direction}): Walk ${Math.round(route.boardingDistance)}m to ${route.boardingStopName}, alight at ${route.alightingStopName} (${route.stopCount} stops)<br>
                            Walk ${Math.round(route.walkingDistance)}m to ${getStationFullName(route.interchangeStation)}<br>
                            MTR: ${route.mtrRoute.route.map(l => lineNames[l]).join(' → ')}
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h4>Bus Segment</h4>
                            <ul class="stop-list">${route.busRoute.stops.map(s => `<li class="${s.id === route.busRoute.boardingStop ? 'boarding-stop' : s.id === route.busRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.busRoute.boardingStop ? `<span id="eta-${i}"></span>` : ''}</li>`).join('')}</ul>
                            <p>Walk ${Math.round(route.walkingDistance)}m to ${getStationFullName(route.interchangeStation)}</p>
                            <h4>MTR Segment</h4>
                            ${route.mtrRoute.route.map(line => {
                                const direction = getDirection(route.interchangeStation, route.to, line, route.schedules);
                                const trains = route.schedules[line]?.[direction] || [];
                                const nextTrain = trains.find(t => new Date(t.time) > new Date()) || trains[0];
                                return `
                                    <h5>${lineNames[line]}</h5>
                                    <table class="schedule-table">
                                        <tr><th>Next Train (mins)</th><th>Platform</th><th>Destination</th><th>Sequence</th></tr>
                                        ${nextTrain ? `<tr><td>${calculateETAMins(nextTrain.time)}</td><td>${nextTrain.plat}</td><td>${getStationFullName(nextTrain.dest)}</td><td>${nextTrain.seq}</td></tr>` : '<tr><td colspan="4">No upcoming trains</td></tr>'}
                                    </table>
                                `;
                            }).join('')}
                        </div>
                    `;
                } else if (route.type === 'MTR-to-Bus') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            MTR: ${route.mtrRoute.route.map(l => lineNames[l]).join(' → ')}: From ${getStationFullName(route.from)} to ${getStationFullName(route.to)}<br>
                            Then walk ${Math.round(route.walkingDistance)}m to ${route.endStopName} (Bus Stop)
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h4>MTR Segment</h4>
                            ${route.mtrRoute.route.map(line => {
                                const direction = getDirection(route.from, route.to, line, route.schedules);
                                const trains = route.schedules[line]?.[direction] || [];
                                const nextTrain = trains.find(t => new Date(t.time) > new Date()) || trains[0];
                                return `
                                    <h5>${lineNames[line]}</h5>
                                    <table class="schedule-table">
                                        <tr><th>Next Train (mins)</th><th>Platform</th><th>Destination</th><th>Sequence</th></tr>
                                        ${nextTrain ? `<tr><td>${calculateETAMins(nextTrain.time)}</td><td>${nextTrain.plat}</td><td>${getStationFullName(nextTrain.dest)}</td><td>${nextTrain.seq}</td></tr>` : '<tr><td colspan="4">No upcoming trains</td></tr>'}
                                    </table>
                                `;
                            }).join('')}
                            <p>Then walk ${Math.round(route.walkingDistance)}m to ${route.endStopName} (Bus Stop)</p>
                        </div>
                    `;
                }
                opts.innerHTML += html;
            });
        }

        function toggleRouteDetails(id, el) {
            const details = document.getElementById(id);
            details.style.display = details.style.display === 'none' ? 'block' : 'none';
            if (details.style.display === 'block' && currentRoutes) {
                const routeIndex = parseInt(id.split('-')[2]);
                const route = currentRoutes[routeIndex];
                if (route.type === 'Bus' || route.type === 'Bus-to-MTR') {
                    const company = localStorage.getItem('company') || 'Citybus';
                    fetchETA(route.busRoute.route, route.busRoute.direction, route.busRoute.boardingStop, id, company);
                }
            }
        }

        async function fetchETA(route, dir, stop, detailsId, company) {
            const span = document.querySelector(`#${detailsId} .boarding-stop span`) || document.createElement('span');
            try {
                const url = company === 'KMB' ? `https://data.etabus.gov.hk/v1/transport/kmb/eta/${stop}/${route}/1` : `https://rt.data.gov.hk/v2/transport/citybus/eta/CTB/${stop}/${route}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const { data } = await response.json();
                const dirMapping = { "outbound": "O", "inbound": "I" };
                const direction = dirMapping[dir] || dir;
                let eta = company === 'KMB' ? data.find(e => e.seq === 1 && e.dir === direction) || data.find(e => e.seq === 1) : data.find(e => e.eta_seq === 1 && e.dir === direction) || data.find(e => e.eta_seq === 1);
                if (eta?.eta) {
                    const mins = Math.round((new Date(eta.eta) - new Date(company === 'KMB' ? null : eta.data_timestamp)) / 60000);
                    span.textContent = mins >= 0 ? ` (ETA: ${mins} min)` : ` (Due now)`;
                } else {
                    span.textContent = ` (No ETA data)`;
                }
            } catch (e) {
                span.textContent = ` (ETA unavailable)`;
            }
        }

        function calculateETAMins(trainTime) {
            const now = new Date();
            const trainDate = new Date(trainTime);
            const diffMs = trainDate - now;
            const mins = Math.round(diffMs / 60000);
            return mins >= 0 ? mins : 'Due';
        }

        function getDirection(currentStation, destinationStation, line, schedules) {
            const lineStations = lines[line];
            const currentIndex = lineStations.findIndex(s => s.value === currentStation);
            const destIndex = lineStations.findIndex(s => s.value === destinationStation);
            return destIndex > currentIndex ? 'up' : 'down';
        }

        const getStationFullName = code => Object.values(lines).flat().find(s => s.value === code)?.text || code;

        function setupSortButtons() {
            const sortByTimeBtn = document.getElementById('sortByTime');
            const sortByWalkBtn = document.getElementById('sortByWalk');

            sortByTimeBtn.addEventListener('click', () => {
                sortByTimeAsc = !sortByTimeAsc;
                currentRoutes.sort((a, b) => sortByTimeAsc ? a.estimatedTime - b.estimatedTime : b.estimatedTime - a.estimatedTime);
                displaySortedRoutes();
                sortByTimeBtn.classList.add('active');
                sortByWalkBtn.classList.remove('active');
                sortByTimeBtn.textContent = `Sort by Time (${sortByTimeAsc ? 'Fastest' : 'Slowest'})`;
            });

            sortByWalkBtn.addEventListener('click', () => {
                sortByWalkAsc = !sortByWalkAsc;
                currentRoutes.sort((a, b) => sortByWalkAsc ? a.walkingDistance - b.walkingDistance : b.walkingDistance - a.walkingDistance);
                displaySortedRoutes();
                sortByWalkBtn.classList.add('active');
                sortByTimeBtn.classList.remove('active');
                sortByWalkBtn.textContent = `Sort by Walk Distance (${sortByWalkAsc ? 'Shortest' : 'Longest'})`;
            });
        }
    </script>
</body>
</html>
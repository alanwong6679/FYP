<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>General Schedule</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/navbar.css">
    <link rel="stylesheet" href="/static/css/general_schedule.css">
</head>
<body>
    <header><h1>MTR & Bus Schedule</h1></header>
    <div class="container">
        <div class="sort-buttons">
            <button class="sort-button" id="sortByTime">Sort by Time</button>
            <button class="sort-button" id="sortByWalk">Sort by Walk Distance</button>
        </div>
        <div id="route-options"></div>
        <div id="schedule" class="schedule-detail"></div>
    </div>
    <div class="news-icon"></div>
    <div id="newsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="toggleModal()">×</span>
            <div class="language-switch"><button id="btnChinese">中文</button><button id="btnEnglish">English</button></div>
            <div id="newsContent">Loading...</div>
            <div class="source-reference">Source: RTHK</div>
        </div>
    </div>
    <script src="/static/js/stations.js"></script>
    <script src="/static/js/navbar.js"></script>
    <script src="/static/js/RTHK.js"></script>
    <script>
        const lineNames = {
            "AEL": "Airport Express Line <span style='display:inline-block;width:20px;height:10px;background:#00888A;border-radius:5px'></span>",
            "TCL": "Tung Chung Line <span style='display:inline-block;width:20px;height:10px;background:#F7943E;border-radius:5px'></span>",
            "TML": "Tuen Ma Line <span style='display:inline-block;width:20px;height:10px;background:#923011;border-radius:5px'></span>",
            "TKL": "Tseung Kwan O Line <span style='display:inline-block;width:20px;height:10px;background:#7D499D;border-radius:5px'></span>",
            "EAL": "East Rail Line <span style='display:inline-block;width:20px;height:10px;background:#53B7E8;border-radius:5px'></span>",
            "SIL": "South Island Line <span style='display:inline-block;width:20px;height:10px;background:#BAC429;border-radius:5px'></span>",
            "TWL": "Tsuen Wan Line <span style='display:inline-block;width:20px;height:10px;background:#ED1D24;border-radius:5px'></span>",
            "ISL": "Island Line <span style='display:inline-block;width:20px;height:10px;background:#007DC5;border-radius:5px'></span>",
            "KTL": "Kwun Tong Line <span style='display:inline-block;width:20px;height:10px;background:#00AB4E;border-radius:5px'></span>"
        };
        let allRoutes = [], allStops = [], routeStopsMap = {},
            originalContent = '', currentRoutes = [],
            sortByTimeAsc = true, sortByWalkAsc = true;

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        function findNearbyStops(station, radius = 1000) {
            return allStops.filter(s => 
                s.lat && s.long && station.lat && station.long && 
                haversineDistance(parseFloat(s.lat), parseFloat(s.long), station.lat, station.long) <= radius
            );
        }

        function findNearestMTRStation(busStop, mtrStations) {
            if (!busStop || !busStop.lat || !busStop.long) return { station: null, distance: NaN };
            let minDistance = Infinity, nearest = null;
            for (const station of mtrStations) {
                if (!station.lat || !station.long) continue;
                const distance = haversineDistance(parseFloat(busStop.lat), parseFloat(busStop.long), station.lat, station.long);
                if (!isNaN(distance) && distance < minDistance) {
                    minDistance = distance;
                    nearest = station;
                }
            }
            return { station: nearest, distance: minDistance };
        }

        function getUniqueMTRStations() {
            const stationSet = new Set();
            const stations = [];
            for (let line in lines) {
                lines[line].forEach(station => {
                    if (!stationSet.has(station.value)) {
                        stationSet.add(station.value);
                        stations.push({ value: station.value, text: station.text, lat: station.lat, long: station.long });
                    }
                });
            }
            return stations;
        }

       

        const toggleModal = () => document.getElementById('newsModal').style.display = 
            document.getElementById('newsModal').style.display === 'block' ? 'none' : 'block';

        const fetchNewsContent = () => fetch('https://programme.rthk.hk/channel/radio/trafficnews/index.php')
            .then(r => r.text())
            .then(d => {
                const doc = new DOMParser().parseFromString(d, 'text/html');
                originalContent = Array.from(doc.querySelectorAll('ul.dec > li.inner'))
                    .map(i => `<div class="news-item">${i.textContent.trim()}</div>`).join('') || 'No news.';
                document.getElementById('newsContent').innerHTML = originalContent;
                toggleModal();
            })
            .catch(e => console.error('News fetch error:', e));

        const fetchSchedule = async (cs, ds) => {
            try {
                const response = await fetch('/fetch_schedule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ currentStation: cs, destinationStation: ds })
                });
                const { error, schedules, bestRoute, alternativeRoutes } = await response.json();
                document.getElementById('schedule').innerHTML = error ? `<div class="error">${error}</div>` : '';
                if (!error) displayRouteOptions(bestRoute, alternativeRoutes, schedules, cs, ds);
            } catch (e) {
                document.getElementById('schedule').innerHTML = '<div class="error">Fetch failed.</div>';
                console.error('Schedule error:', e);
            }
        };

        const displayRouteOptions = (best, alts, schedules, cs, ds) => {
            currentRoutes = [[best, 'Best Route'], ...alts.map((r, i) => [r, `Alternative Route ${i + 1}`])].map(([r, n]) => ({
                type: 'MTR',
                route: r,
                schedules,
                from: cs,
                to: ds,
                name: n,
                estimatedTime: r.route.reduce((t, l) => t + lines[l].length * 2, 0) + r.interchangeCount * 5,
                walkingDistance: 0
            }));
            displaySortedRoutes();
        };

        const fetchBusRoutes = (start, end) => {
            const [ss, es] = [allStops.find(s => s.stop === start), allStops.find(s => s.stop === end)];
            if (!ss || !es) return document.getElementById('schedule').innerHTML = '<p>Invalid bus stops.</p>';
            const [startStops, endStops] = [findNearbyStops(ss), findNearbyStops(es)];
            const [startIds, endIds] = [startStops.map(s => s.stop), endStops.map(s => s.stop)];
            const routes = [];

            allRoutes.forEach(r => ['outbound', 'inbound'].forEach(d => {
                const key = `${r.route}-${d === 'outbound' ? 'O' : 'I'}`;
                const stops = routeStopsMap[key] || [];
                const sm = stops.filter(id => startIds.includes(id));
                const em = stops.filter(id => endIds.includes(id));
                if (sm.length && em.length) {
                    const cs = sm.reduce((a, id) => {
                        const s = allStops.find(s => s.stop === id);
                        const d = haversineDistance(parseFloat(ss.lat), parseFloat(ss.long), parseFloat(s.lat), parseFloat(s.long));
                        return d < a[1] ? [id, d] : a;
                    }, ['', Infinity])[0];
                    const si = stops.indexOf(cs);
                    const pes = em.filter(id => stops.indexOf(id) > si);
                    if (pes.length) {
                        const ce = pes.reduce((a, id) => {
                            const s = allStops.find(s => s.stop === id);
                            const d = haversineDistance(parseFloat(es.lat), parseFloat(es.long), parseFloat(s.lat), parseFloat(s.long));
                            return d < a[1] ? [id, d] : a;
                        }, ['', Infinity])[0];
                        routes.push({
                            type: 'Bus',
                            busRoute: { 
                                route: r.route, 
                                direction: d, 
                                stops: stops.map(id => ({ id, name: allStops.find(s => s.stop === id)?.name_en || `Stop ${id}` })), 
                                boardingStop: cs, 
                                alightingStop: ce,
                                provider: r.provider // Use provider
                            },
                            boardingDistance: haversineDistance(parseFloat(ss.lat), parseFloat(ss.long), parseFloat(allStops.find(s => s.stop === cs).lat), parseFloat(allStops.find(s => s.stop === cs).long)),
                            alightingDistance: haversineDistance(parseFloat(es.lat), parseFloat(es.long), parseFloat(allStops.find(s => s.stop === ce).lat), parseFloat(allStops.find(s => s.stop === ce).long)),
                            estimatedTime: (stops.indexOf(ce) - stops.indexOf(cs)) * 2,
                            walkingDistance: haversineDistance(parseFloat(ss.lat), parseFloat(ss.long), parseFloat(allStops.find(s => s.stop === cs).lat), parseFloat(allStops.find(s => s.stop === cs).long)) + 
                                            haversineDistance(parseFloat(es.lat), parseFloat(es.long), parseFloat(allStops.find(s => s.stop === ce).lat), parseFloat(allStops.find(s => s.stop === ce).long))
                        });
                    }
                }
            }));
            currentRoutes = routes;
            displaySortedRoutes();
        };

        async function fetchBusToMTR(startBusStop, destinationStation, mtrStations) {
            const startStop = allStops.find(s => s.stop === startBusStop);
            console.log("Start Stop:", startStop);
            if (!startStop) {
                document.getElementById('schedule').innerHTML = '<p>Invalid starting bus stop.</p>';
                return;
            }

            const kmbStops = JSON.parse(localStorage.getItem('kmb_allStops') || '[]');
            const citybusStops = JSON.parse(localStorage.getItem('citybus_allStops') || '[]');
            const isKMB = kmbStops.some(s => s.stop === startBusStop);
            const provider = isKMB ? 'kmb' : 'ctb'; // Match JSON's lowercase 'kmb' and 'ctb'
            console.log("Detected Provider:", provider);

            const nearbyStartStops = findNearbyStops(startStop, 500);
            const nearbyStartStopIds = nearbyStartStops.map(s => s.stop);
            console.log("Nearby Start Stops:", nearbyStartStops);

            const busRoutes = findBusRoutesToStops(nearbyStartStopIds, allStops.map(s => s.stop), provider);
            console.log("Bus Routes:", busRoutes);

            if (!busRoutes.length) {
                document.getElementById('schedule').innerHTML = '<p>No bus routes found.</p>';
                return;
            }

            const routes = [];
            for (const busRoute of busRoutes) {
                const boardingStop = allStops.find(s => s.stop === busRoute.boardingStop);
                const alightingStop = allStops.find(s => s.stop === busRoute.alightingStop);
                const stopCount = busRoute.stops.findIndex(s => s.id === busRoute.alightingStop) - 
                                 busRoute.stops.findIndex(s => s.id === busRoute.boardingStop);

                const busDetails = {
                    busRoute,
                    boardingStopName: boardingStop?.name_en || `Stop ${busRoute.boardingStop}`,
                    alightingStopName: alightingStop?.name_en || `Stop ${busRoute.alightingStop}`,
                    boardingDistance: busRoute.boardingDistance,
                    stopCount
                };

                const nearbyMTRs = mtrStations
                    .map(station => ({
                        station,
                        distance: haversineDistance(parseFloat(alightingStop.lat), parseFloat(alightingStop.long), station.lat, station.long)
                    }))
                    .filter(m => !isNaN(m.distance))
                    .sort((a, b) => a.distance - b.distance)
                    .slice(0, 3);

                for (const { station, distance } of nearbyMTRs) {
                    const interchangeStation = station.value;
                    const walkingDistanceToMTR = distance;

                    const mtrResponse = await fetch('/fetch_schedule', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ currentStation: interchangeStation, destinationStation })
                    }).then(res => res.json()).catch(() => ({ error: 'MTR schedule unavailable' }));

                    if (!mtrResponse.error) {
                        const busTime = stopCount * 2;
                        const walkingTime = walkingDistanceToMTR / 5000 * 60;
                        const mtrTime = mtrResponse.bestRoute.route.reduce((t, l) => t + lines[l].length * 2, 0) + mtrResponse.bestRoute.interchangeCount * 5;
                        routes.push({
                            type: 'Bus-to-MTR',
                            ...busDetails,
                            mtrRoute: mtrResponse.bestRoute,
                            interchangeStation,
                            walkingDistance: walkingDistanceToMTR,
                            schedules: mtrResponse.schedules,
                            estimatedTime: Math.round(busTime + walkingTime + mtrTime)
                        });
                    }
                }
            }
            currentRoutes = routes;
            displaySortedRoutes();
        }

        async function fetchMTRToBus(currentStation, endBusStop, mtrStations) {
            const endStop = allStops.find(s => s.stop === endBusStop);
            if (!endStop) {
                document.getElementById('schedule').innerHTML = '<p>Invalid ending bus stop.</p>';
                return;
            }

            const nearbyMTRs = mtrStations
                .map(station => ({
                    station,
                    distance: haversineDistance(parseFloat(endStop.lat), parseFloat(endStop.long), station.lat, station.long)
                }))
                .filter(m => !isNaN(m.distance))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 3);

            const routes = [];
            for (const { station, distance } of nearbyMTRs) {
                const destinationMTRStation = station.value;
                const walkingDistance = distance;

                const mtrResponse = await fetch('/fetch_schedule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ currentStation, destinationStation: destinationMTRStation })
                }).then(res => res.json()).catch(() => ({ error: 'MTR schedule unavailable' }));

                if (!mtrResponse.error) {
                    const mtrTime = mtrResponse.bestRoute.route.reduce((t, l) => t + lines[l].length * 2, 0) + mtrResponse.bestRoute.interchangeCount * 5;
                    const walkingTime = walkingDistance / 5000 * 60;
                    routes.push({
                        type: 'MTR-to-Bus',
                        mtrRoute: mtrResponse.bestRoute,
                        schedules: mtrResponse.schedules,
                        from: currentStation,
                        to: destinationMTRStation,
                        walkingDistance,
                        endStopName: endStop.name_en,
                        estimatedTime: Math.round(mtrTime + walkingTime)
                    });

                    if (mtrResponse.alternativeRoutes?.length) {
                        mtrResponse.alternativeRoutes.forEach(altRoute => {
                            const altMtrTime = altRoute.route.reduce((t, l) => t + lines[l].length * 2, 0) + altRoute.interchangeCount * 5;
                            routes.push({
                                type: 'MTR-to-Bus',
                                mtrRoute: altRoute,
                                schedules: mtrResponse.schedules,
                                from: currentStation,
                                to: destinationMTRStation,
                                walkingDistance,
                                endStopName: endStop.name_en,
                                estimatedTime: Math.round(altMtrTime + walkingTime)
                            });
                        });
                    }
                }
            }
            currentRoutes = routes;
            displaySortedRoutes();
        }

        async function fetchCTBToKMB(startBusStop, endBusStop) {
            const startStop = allStops.find(s => s.stop === startBusStop);
            const endStop = allStops.find(s => s.stop === endBusStop);
            if (!startStop || !endStop) {
                document.getElementById('schedule').innerHTML = '<p>Invalid bus stops.</p>';
                return;
            }

            const ctbRoutes = JSON.parse(localStorage.getItem('citybus_allRoutes') || '[]');
            const kmbRoutes = JSON.parse(localStorage.getItem('kmb_allRoutes') || '[]');
            const ctbStops = JSON.parse(localStorage.getItem('citybus_allStops') || '[]');
            const kmbStops = JSON.parse(localStorage.getItem('kmb_allStops') || '[]');
            const ctbRouteStopsMap = JSON.parse(localStorage.getItem('citybus_routeStopsMap') || '{}');
            const kmbRouteStopsMap = JSON.parse(localStorage.getItem('kmb_routeStopsMap') || '{}');

            const nearbyStartStops = findNearbyStops(startStop, 500);
            const nearbyStartStopIds = nearbyStartStops.map(s => s.stop);
            const ctbRouteOptions = findBusRoutesToStops(nearbyStartStopIds, ctbStops.map(s => s.stop), 'ctb', ctbRoutes, ctbStops, ctbRouteStopsMap);

            if (!ctbRouteOptions.length) {
                document.getElementById('schedule').innerHTML = '<p>No Citybus routes found.</p>';
                return;
            }

            const routes = [];
            for (const ctbRoute of ctbRouteOptions) {
                const ctbAlightingStop = ctbStops.find(s => s.stop === ctbRoute.alightingStop);
                const nearbyKMBStops = findNearbyStops(ctbAlightingStop, 500);
                const nearbyKMBStopIds = nearbyKMBStops.map(s => s.stop);
                const kmbRouteOptions = findBusRoutesToStops(nearbyKMBStopIds, [endBusStop], 'kmb', kmbRoutes, kmbStops, kmbRouteStopsMap);

                for (const kmbRoute of kmbRouteOptions) {
                    const kmbBoardingStop = kmbStops.find(s => s.stop === kmbRoute.boardingStop);
                    const walkingDistance = haversineDistance(
                        parseFloat(ctbAlightingStop.lat), parseFloat(ctbAlightingStop.long),
                        parseFloat(kmbBoardingStop.lat), parseFloat(kmbBoardingStop.long)
                    );

                    const ctbStopCount = ctbRoute.stops.findIndex(s => s.id === ctbRoute.alightingStop) -
                                        ctbRoute.stops.findIndex(s => s.id === ctbRoute.boardingStop);
                    const kmbStopCount = kmbRoute.stops.findIndex(s => s.id === kmbRoute.alightingStop) -
                                        kmbRoute.stops.findIndex(s => s.id === kmbRoute.boardingStop);

                    const ctbTime = ctbStopCount * 2;
                    const walkingTime = walkingDistance / 5000 * 60;
                    const kmbTime = kmbStopCount * 2;

                    routes.push({
                        type: 'CTB-to-KMB',
                        ctbRoute,
                        kmbRoute,
                        ctbBoardingStopName: ctbStops.find(s => s.stop === ctbRoute.boardingStop)?.name_en || `Stop ${ctbRoute.boardingStop}`,
                        ctbAlightingStopName: ctbStops.find(s => s.stop === ctbRoute.alightingStop)?.name_en || `Stop ${ctbRoute.alightingStop}`,
                        kmbBoardingStopName: kmbStops.find(s => s.stop === kmbRoute.boardingStop)?.name_en || `Stop ${kmbRoute.boardingStop}`,
                        kmbAlightingStopName: kmbStops.find(s => s.stop === kmbRoute.alightingStop)?.name_en || `Stop ${kmbRoute.alightingStop}`,
                        ctbBoardingDistance: ctbRoute.boardingDistance,
                        walkingDistance,
                        kmbAlightingDistance: kmbRoute.alightingDistance,
                        estimatedTime: Math.round(ctbTime + walkingTime + kmbTime),
                        ctbStopCount,
                        kmbStopCount
                    });
                }
            }

            currentRoutes = routes.length ? routes : [];
            if (!routes.length) document.getElementById('schedule').innerHTML = '<p>No transfer routes found.</p>';
            displaySortedRoutes();
        }

        function findBusRoutesToStops(startBusStopIds, targetStopIds, provider, routes = allRoutes, stops = allStops, routeMap = routeStopsMap) {
            const directRoutes = [];
            const startStops = Array.isArray(startBusStopIds) ? startBusStopIds.map(id => stops.find(s => s.stop === id)) : [stops.find(s => s.stop === startBusStopIds)];
            const startStopIdsArray = Array.isArray(startBusStopIds) ? startBusStopIds : [startBusStopIds];
            console.log("Start Stop IDs:", startStopIdsArray);
            console.log("Target Stop IDs Sample:", targetStopIds.slice(0, 5)); // Sample for brevity
            console.log("Provider:", provider);

            const filteredRoutes = provider ? routes.filter(r => r.provider === provider) : routes;
            console.log("Filtered Routes:", filteredRoutes);

            for (const route of filteredRoutes) {
                for (const direction of ['outbound', 'inbound']) {
                    const key = `${route.route}-${direction === 'outbound' ? 'O' : 'I'}`;
                    const stopsList = routeMap[key] || [];
                    console.log(`Route ${key} Stops:`, stopsList);
                    const startMatches = stopsList.filter(id => startStopIdsArray.includes(id));
                    const endMatches = stopsList.filter(id => targetStopIds.includes(id));
                    console.log(`Start Matches for ${key}:`, startMatches);
                    console.log(`End Matches for ${key}:`, endMatches);

                    if (startMatches.length && endMatches.length) {
                        let closestStartStop = null, minStartDistance = Infinity;
                        const referenceStartStop = startStops[0];
                        for (const stopId of startMatches) {
                            const stop = stops.find(s => s.stop === stopId);
                            const distance = haversineDistance(parseFloat(referenceStartStop.lat), parseFloat(referenceStartStop.long), parseFloat(stop.lat), parseFloat(stop.long));
                            if (distance < minStartDistance) {
                                minStartDistance = distance;
                                closestStartStop = stopId;
                            }
                        }
                        const startIndex = stopsList.indexOf(closestStartStop);
                        const possibleEndStops = endMatches.filter(id => stopsList.indexOf(id) > startIndex);
                        if (possibleEndStops.length) {
                            let closestEndStop = null, minEndDistance = Infinity;
                            const referenceEndStop = stops.find(s => s.stop === targetStopIds[0]);
                            for (const stopId of possibleEndStops) {
                                const stop = stops.find(s => s.stop === stopId);
                                const distance = haversineDistance(parseFloat(referenceEndStop.lat), parseFloat(referenceEndStop.long), parseFloat(stop.lat), parseFloat(stop.long));
                                if (distance < minEndDistance) {
                                    minEndDistance = distance;
                                    closestEndStop = stopId;
                                }
                            }
                            const stopDetails = stopsList.map(id => ({
                                id,
                                name: stops.find(s => s.stop === id)?.name_en || `Stop ${id}`
                            }));
                            directRoutes.push({
                                route: route.route,
                                direction,
                                stops: stopDetails,
                                boardingStop: closestStartStop,
                                alightingStop: closestEndStop,
                                boardingDistance: minStartDistance,
                                alightingDistance: minEndDistance,
                                provider: route.provider
                            });
                        }
                    }
                }
            }
            return directRoutes;
        }

        function displaySortedRoutes() {
            const opts = document.getElementById('route-options');
            opts.innerHTML = '';
            const now = new Date();
            const currentTime = now.toTimeString().slice(0, 5);

            currentRoutes.slice(0, 7).forEach((route, i) => {
                const arrivalTime = new Date(now.getTime() + route.estimatedTime * 60000);
                const arrivalTimeStr = arrivalTime.toTimeString().slice(0, 5);
                let html = '';
                const getStopName = stopId => allStops.find(s => s.stop === stopId)?.name_en || `Stop ${stopId}`;

                if (route.type === 'MTR') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>${route.name}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            ${route.route.route.map(l => lineNames[l]).join(' → ')} (${route.route.interchangeCount} interchange${route.route.interchangeCount !== 1 ? 's' : ''})
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h2>From ${getStationFullName(route.from)} to ${getStationFullName(route.to)}</h2>
                            ${route.route.route.map(line => `
                                <h3>${lineNames[line]}</h3>
                                <div><strong>Current Time:</strong> ${route.schedules[line]?.curr_time || '-'}</div>
                                <h4>UP Trains</h4><table class="schedule-table"><tr><th>Time</th><th>Platform</th><th>Destination</th><th>Sequence</th><th>Valid</th></tr>${route.schedules[line]?.up?.length ? route.schedules[line].up.map(t => `<tr><td>${t.time}</td><td>${t.plat}</td><td>${getStationFullName(t.dest)}</td><td>${t.seq}</td><td>${t.valid}</td></tr>`).join('') : '<tr><td colspan="5">No UP trains</td></tr>'}</table>
                                <h4>DOWN Trains</h4><table class="schedule-table"><tr><th>Time</th><th>Platform</th><th>Destination</th><th>Sequence</th><th>Valid</th></tr>${route.schedules[line]?.down?.length ? route.schedules[line].down.map(t => `<tr><td>${t.time}</td><td>${t.plat}</td><td>${getStationFullName(t.dest)}</td><td>${t.seq}</td><td>${t.valid}</td></tr>`).join('') : '<tr><td colspan="5">No DOWN trains</td></tr>'}</table>
                            `).join('')}
                        </div>`;
                } else if (route.type === 'Bus') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            Bus ${route.busRoute.route} (${route.busRoute.direction}) - ${route.busRoute.stops.length - 1} stops<br>
                            Walk ${Math.round(route.boardingDistance)}m to ${getStopName(route.busRoute.boardingStop)}, alight at ${getStopName(route.busRoute.alightingStop)} (${Math.round(route.alightingDistance)}m)
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <ul class="stop-list">${route.busRoute.stops.map(s => `<li class="${s.id === route.busRoute.boardingStop ? 'boarding-stop' : s.id === route.busRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.busRoute.boardingStop ? `<span id="eta-${i}"></span>` : ''}</li>`).join('')}</ul>
                        </div>`;
                } else if (route.type === 'Bus-to-MTR') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            Bus ${route.busRoute.route} (${route.busRoute.direction}): Walk ${Math.round(route.boardingDistance)}m to ${route.boardingStopName}, alight at ${route.alightingStopName} (${route.stopCount} stops)<br>
                            Walk ${Math.round(route.walkingDistance)}m to ${getStationFullName(route.interchangeStation)}<br>
                            MTR: ${route.mtrRoute.route.map(l => lineNames[l]).join(' → ')}
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h4>Bus Segment</h4>
                            <ul class="stop-list">${route.busRoute.stops.map(s => `<li class="${s.id === route.busRoute.boardingStop ? 'boarding-stop' : s.id === route.busRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.busRoute.boardingStop ? `<span id="eta-${i}"></span>` : ''}</li>`).join('')}</ul>
                            <p>Walk ${Math.round(route.walkingDistance)}m to ${getStationFullName(route.interchangeStation)}</p>
                            <h4>MTR Segment</h4>
                            ${route.mtrRoute.route.map(line => {
                                const direction = getDirection(route.interchangeStation, route.to, line, route.schedules);
                                const trains = route.schedules[line]?.[direction] || [];
                                const nextTrain = trains.find(t => new Date(t.time) > new Date()) || trains[0];
                                return `
                                    <h5>${lineNames[line]}</h5>
                                    <table class="schedule-table">
                                        <tr><th>Next Train (mins)</th><th>Platform</th><th>Destination</th><th>Sequence</th></tr>
                                        ${nextTrain ? `<tr><td>${calculateETAMins(nextTrain.time)}</td><td>${nextTrain.plat}</td><td>${getStationFullName(nextTrain.dest)}</td><td>${nextTrain.seq}</td></tr>` : '<tr><td colspan="4">No upcoming trains</td></tr>'}
                                    </table>`;
                            }).join('')}
                        </div>`;
                } else if (route.type === 'MTR-to-Bus') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            MTR: ${route.mtrRoute.route.map(l => lineNames[l]).join(' → ')}: From ${getStationFullName(route.from)} to ${getStationFullName(route.to)}<br>
                            Then walk ${Math.round(route.walkingDistance)}m to ${route.endStopName} (Bus Stop)
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h4>MTR Segment</h4>
                            ${route.mtrRoute.route.map(line => {
                                const direction = getDirection(route.from, route.to, line, route.schedules);
                                const trains = route.schedules[line]?.[direction] || [];
                                const nextTrain = trains.find(t => new Date(t.time) > new Date()) || trains[0];
                                return `
                                    <h5>${lineNames[line]}</h5>
                                    <table class="schedule-table">
                                        <tr><th>Next Train (mins)</th><th>Platform</th><th>Destination</th><th>Sequence</th></tr>
                                        ${nextTrain ? `<tr><td>${calculateETAMins(nextTrain.time)}</td><td>${nextTrain.plat}</td><td>${getStationFullName(nextTrain.dest)}</td><td>${nextTrain.seq}</td></tr>` : '<tr><td colspan="4">No upcoming trains</td></tr>'}
                                    </table>`;
                            }).join('')}
                            <p>Then walk ${Math.round(route.walkingDistance)}m to ${route.endStopName} (Bus Stop)</p>
                        </div>`;
                } else if (route.type === 'CTB-to-KMB') {
                    html = `
                        <div class="route-option" id="route-summary-${i}" onclick="toggleRouteDetails('route-details-${i}', this)">
                            <strong>Route ${i + 1}</strong><br>
                            <div class="time-display">${currentTime} → ${arrivalTimeStr} <span class="eta">(${route.estimatedTime} mins)</span></div>
                            Citybus ${route.ctbRoute.route} (${route.ctbRoute.direction}): Walk ${Math.round(route.ctbBoardingDistance)}m to ${route.ctbBoardingStopName}, alight at ${route.ctbAlightingStopName} (${route.ctbStopCount} stops)<br>
                            Walk ${Math.round(route.walkingDistance)}m to ${route.kmbBoardingStopName}<br>
                            KMB ${route.kmbRoute.route} (${route.kmbRoute.direction}): Alight at ${route.kmbAlightingStopName} (${route.kmbStopCount} stops, ${Math.round(route.kmbAlightingDistance)}m walk)
                        </div>
                        <div class="route-details" id="route-details-${i}">
                            <h4>Citybus Segment</h4>
                            <ul class="stop-list">${route.ctbRoute.stops.map(s => `<li class="${s.id === route.ctbRoute.boardingStop ? 'boarding-stop' : s.id === route.ctbRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.ctbRoute.boardingStop ? `<span id="eta-citybus-${i}"></span>` : ''}</li>`).join('')}</ul>
                            <p>Walk ${Math.round(route.walkingDistance)}m to ${route.kmbBoardingStopName}</p>
                            <h4>KMB Segment</h4>
                            <ul class="stop-list">${route.kmbRoute.stops.map(s => `<li class="${s.id === route.kmbRoute.boardingStop ? 'boarding-stop' : s.id === route.kmbRoute.alightingStop ? 'alighting-stop' : ''}">${s.name}${s.id === route.kmbRoute.boardingStop ? `<span id="eta-kmb-${i}"></span>` : ''}</li>`).join('')}</ul>
                        </div>`;
                }
                opts.innerHTML += html;
            });
        }

        function toggleRouteDetails(id, el) {
            const details = document.getElementById(id);
            details.style.display = details.style.display === 'none' ? 'block' : 'none';
            if (details.style.display === 'block' && currentRoutes) {
                const routeIndex = parseInt(id.split('-')[2]);
                const route = currentRoutes[routeIndex];
                if (route.type === 'Bus' || route.type === 'Bus-to-MTR') {
                    // Map 'kmb'/'ctb' to 'KMB'/'Citybus' for ETA API compatibility
                    const etaProvider = route.busRoute.provider === 'kmb' ? 'KMB' : 'Citybus';
                    fetchETA(route.busRoute.route, route.busRoute.direction, route.busRoute.boardingStop, id, etaProvider, routeIndex);
                } else if (route.type === 'CTB-to-KMB') {
                    fetchETA(route.ctbRoute.route, route.ctbRoute.direction, route.ctbRoute.boardingStop, id, 'Citybus', routeIndex);
                    fetchETA(route.kmbRoute.route, route.kmbRoute.direction, route.kmbRoute.boardingStop, id, 'KMB', routeIndex);
                }
            }
        }

        async function fetchETA(route, dir, stop, detailsId, provider, index) {
            const span = document.querySelector(`#${detailsId} .boarding-stop span[id='eta-${provider.toLowerCase()}-${index}']`) || 
                         document.querySelector(`#${detailsId} .boarding-stop span[id='eta-${index}']`);
            if (!span) return;

            try {
                const url = provider === 'KMB' ? `https://data.etabus.gov.hk/v1/transport/kmb/eta/${stop}/${route}/1` : 
                           `https://rt.data.gov.hk/v2/transport/citybus/eta/CTB/${stop}/${route}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const { data } = await response.json();
                const dirMapping = { "outbound": "O", "inbound": "I" };
                const direction = dirMapping[dir] || dir;
                let eta = provider === 'KMB' ? data.find(e => e.seq === 1 && e.dir === direction) || data.find(e => e.seq === 1) :
                          data.data.find(e => e.eta_seq === 1 && e.dir === direction) || data.data.find(e => e.eta_seq === 1);
                if (eta?.eta) {
                    const mins = Math.round((new Date(eta.eta) - new Date(provider === 'KMB' ? eta.generated_timestamp : eta.data_timestamp)) / 60000);
                    span.textContent = mins >= 0 ? ` (ETA: ${mins} min)` : ` (Due now)`;
                } else {
                    span.textContent = ` (No ETA data)`;
                }
            } catch (e) {
                span.textContent = ` (ETA unavailable)`;
                console.error(`ETA fetch error for ${provider} route ${route} at stop ${stop}:`, e);
            }
        }

        function calculateETAMins(trainTime) {
            const now = new Date();
            const trainDate = new Date(trainTime);
            const diffMs = trainDate - now;
            const mins = Math.round(diffMs / 60000);
            return mins >= 0 ? mins : 'Due';
        }

        function getDirection(currentStation, destinationStation, line, schedules) {
            const lineStations = lines[line];
            const currentIndex = lineStations.findIndex(s => s.value === currentStation);
            const destIndex = lineStations.findIndex(s => s.value === destinationStation);
            return destIndex > currentIndex ? 'up' : 'down';
        }

        const getStationFullName = code => Object.values(lines).flat().find(s => s.value === code)?.text || code;

        function setupSortButtons() {
            const sortByTimeBtn = document.getElementById('sortByTime');
            const sortByWalkBtn = document.getElementById('sortByWalk');

            sortByTimeBtn.addEventListener('click', () => {
                sortByTimeAsc = !sortByTimeAsc;
                currentRoutes.sort((a, b) => sortByTimeAsc ? a.estimatedTime - b.estimatedTime : b.estimatedTime - a.estimatedTime);
                displaySortedRoutes();
                sortByTimeBtn.classList.add('active');
                sortByWalkBtn.classList.remove('active');
                sortByTimeBtn.textContent = `Sort by Time (${sortByTimeAsc ? 'Fastest' : 'Slowest'})`;
            });

            sortByWalkBtn.addEventListener('click', () => {
                sortByWalkAsc = !sortByWalkAsc;
                currentRoutes.sort((a, b) => sortByWalkAsc ? a.walkingDistance - b.walkingDistance : b.walkingDistance - a.walkingDistance);
                displaySortedRoutes();
                sortByWalkBtn.classList.add('active');
                sortByTimeBtn.classList.remove('active');
                sortByWalkBtn.textContent = `Sort by Walk Distance (${sortByWalkAsc ? 'Shortest' : 'Longest'})`;
            });
        }


        window.onload = () => {
    const params = new URLSearchParams(window.location.search);
    const [cs, ds, sbs, ebs, startCompany, endCompany] = [
        params.get('currentStation'),
        params.get('destinationStation'),
        params.get('startBusStop'),
        params.get('endBusStop'),
        params.get('startCompany'),
        params.get('endCompany')
    ];

    allRoutes = [...(JSON.parse(localStorage.getItem('kmb_allRoutes') || '[]')), 
                 ...(JSON.parse(localStorage.getItem('citybus_allRoutes') || '[]'))];
    allStops = [...(JSON.parse(localStorage.getItem('kmb_allStops') || '[]')), 
                ...(JSON.parse(localStorage.getItem('citybus_allStops') || '[]'))];
    routeStopsMap = {...JSON.parse(localStorage.getItem('kmb_routeStopsMap') || '{}'), 
                     ...JSON.parse(localStorage.getItem('citybus_routeStopsMap') || '{}')};

    if (!allStops.length) {
        document.getElementById('schedule').innerHTML = '<div class="error">Bus data not loaded.</div>';
        return;
    }

    if (cs && ds) {
        fetchSchedule(cs, ds);
    } else if (sbs && ebs) {
        if (startCompany && endCompany && startCompany === endCompany) {
            // Bus-to-Bus, same company
            fetchBusRoutes(sbs, ebs, startCompany.toLowerCase()); // Pass provider explicitly
        } else if (startCompany && endCompany && startCompany !== endCompany) {
            // Bus-to-Bus, different companies (e.g., Citybus-to-KMB)
            fetchCTBToKMB(sbs, ebs);
        } else {
            // Fallback: assume same company or try both if unspecified
            fetchBusRoutes(sbs, ebs);
        }
    } else if (sbs && ds) {
        fetchBusToMTR(sbs, ds, getUniqueMTRStations(), startCompany?.toLowerCase() || 'kmb');
    } else if (cs && ebs) {
        fetchMTRToBus(cs, ebs, getUniqueMTRStations());
    } else {
        document.getElementById('schedule').innerHTML = '<div class="error">Invalid parameters.</div>';
    }

    document.querySelector('.news-icon').onclick = fetchNewsContent;
    document.getElementById('btnChinese').onclick = () => document.getElementById('newsContent').innerHTML = originalContent || 'No news.';
    setupSortButtons();
};
    </script>
</body>
</html>
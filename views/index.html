<script>
    // Global variables (already in your code, extended for KMB)
    let allRoutes = [];
    let allStops = [];
    let routeStopsMap = {};

    window.onload = async function() {
        const urlParams = new URLSearchParams(window.location.search);
        const startBusStop = urlParams.get('startBusStop');
        const destinationStation = urlParams.get('destinationStation');
        const currentStation = urlParams.get('currentStation');
        const endBusStop = urlParams.get('endBusStop');

        if (startBusStop && destinationStation) {
            console.log(`Fetching Bus-to-MTR from ${startBusStop} to ${destinationStation}`);
            fetchBusToMTR(startBusStop, destinationStation);
        } else if (currentStation && endBusStop) {
            console.log(`Fetching MTR-to-Bus from ${currentStation} to ${endBusStop}`);
            fetchMTRToBus(currentStation, endBusStop);
        } else if (currentStation && destinationStation) {
            console.log(`Fetching MTR-to-MTR from ${currentStation} to ${destinationStation}`);
        } else {
            console.log('No specific URL params, initializing normally');
        }

        await fetchBusData(); // Combined Citybus and KMB fetch
        await initializeData();
        const mtrStations = getUniqueMTRStations();
        const busStops = allStops.map(stop => ({
            value: stop.stop,
            text: stop.name_en,
            type: 'Bus'
        }));
        const allOptions = [...mtrStations, ...busStops];
        makeSearchable('currentStationInput', 'currentStationOptions', allOptions);
        makeSearchable('destinationStationInput', 'destinationStationOptions', allOptions);
        getTemperature();
    };

    async function fetchBusData() {
        // Fetch Citybus data
        await fetchCitybusData();
        // Fetch KMB data
        await fetchKMBData();
    }

    async function fetchCitybusData() {
        try {
            const routeResponse = await fetch('https://rt.data.gov.hk/v2/transport/citybus/route/CTB');
            if (!routeResponse.ok) {
                console.error(`Citybus route fetch failed: ${routeResponse.status}`);
                return;
            }
            const citybusRoutes = (await routeResponse.json()).data || [];
            allRoutes = allRoutes.concat(citybusRoutes.map(route => ({
                ...route,
                provider: 'CTB'
            })));
        } catch (error) {
            console.error('Error fetching Citybus routes:', error);
        }
        console.log('Citybus routes fetched:', allRoutes.filter(r => r.provider === 'CTB').length);

        const stopsMap = {};
        const routePromises = allRoutes.filter(r => r.provider === 'CTB').map(async route => {
            for (const direction of ['outbound', 'inbound']) {
                try {
                    const response = await fetch(`https://rt.data.gov.hk/v2/transport/citybus/route-stop/CTB/${route.route}/${direction}`);
                    if (!response.ok) {
                        console.warn(`Failed to fetch Citybus stops for ${route.route} (${direction}): ${response.status}`);
                        continue;
                    }
                    const data = await response.json();
                    if (data.data) {
                        const key = `${route.route}-${direction}`;
                        routeStopsMap[key] = data.data.map(stop => stop.stop);
                        data.data.forEach(stop => stopsMap[stop.stop] = stop);
                    }
                } catch (error) {
                    console.warn(`Error fetching Citybus stops for ${route.route} (${direction}):`, error);
                }
            }
        });
        await Promise.all(routePromises);

        const rawStops = Object.values(stopsMap);
        const citybusStops = await Promise.all(rawStops.map(async stop => {
            try {
                const detailsResponse = await fetch(`https://rt.data.gov.hk/v2/transport/citybus/stop/${stop.stop}`);
                if (!detailsResponse.ok) {
                    console.warn(`Failed to fetch Citybus stop details for ${stop.stop}: ${detailsResponse.status}`);
                    return { stop: stop.stop, name_en: `Stop ${stop.stop}`, lat: null, long: null, provider: 'CTB' };
                }
                const details = await detailsResponse.json();
                return {
                    stop: stop.stop,
                    name_en: details.data?.name_en || `Stop ${stop.stop}`,
                    lat: details.data?.lat,
                    long: details.data?.long,
                    provider: 'CTB'
                };
            } catch (error) {
                console.warn(`Error fetching Citybus stop details for ${stop.stop}:`, error);
                return { stop: stop.stop, name_en: `Stop ${stop.stop}`, lat: null, long: null, provider: 'CTB' };
            }
        }));
        allStops = allStops.concat(citybusStops);
        console.log('Citybus stops fetched:', citybusStops.length);
    }

    async function fetchKMBData() {
        try {
            const routeResponse = await fetch('https://data.etabus.gov.hk/v1/transport/kmb/route/');
            if (!routeResponse.ok) {
                console.error(`KMB route fetch failed: ${routeResponse.status}`);
                return;
            }
            const kmbRoutes = (await routeResponse.json()).data || [];
            allRoutes = allRoutes.concat(kmbRoutes.map(route => ({
                route: route.route,
                direction: route.bound === 'O' ? 'outbound' : 'inbound',
                orig_en: route.orig_en,
                dest_en: route.dest_en,
                provider: 'KMB'
            })));
        } catch (error) {
            console.error('Error fetching KMB routes:', error);
        }
        console.log('KMB routes fetched:', allRoutes.filter(r => r.provider === 'KMB').length);

        const stopsMap = {};
        const routePromises = allRoutes.filter(r => r.provider === 'KMB').map(async route => {
            try {
                const response = await fetch(`https://data.etabus.gov.hk/v1/transport/kmb/route-stop`);
                if (!response.ok) {
                    console.warn(`Failed to fetch KMB stops for ${route.route}: ${response.status}`);
                    return;
                }
                const data = await response.json();
                const stops = data.data.filter(item => item.route === route.route && item.bound === (route.direction === 'outbound' ? 'O' : 'I'))
                    .sort((a, b) => a.seq - b.seq);
                const key = `${route.route}-${route.direction}`;
                routeStopsMap[key] = stops.map(stop => stop.stop);
                stops.forEach(stop => stopsMap[stop.stop] = stop);
            } catch (error) {
                console.warn(`Error fetching KMB stops for ${route.route}:`, error);
            }
        });
        await Promise.all(routePromises);

        const rawStops = Object.values(stopsMap);
        const kmbStops = await Promise.all(rawStops.map(async stop => {
            try {
                const detailsResponse = await fetch(`https://data.etabus.gov.hk/v1/transport/kmb/stop/${stop.stop}`);
                if (!detailsResponse.ok) {
                    console.warn(`Failed to fetch KMB stop details for ${stop.stop}: ${detailsResponse.status}`);
                    return { stop: stop.stop, name_en: `Stop ${stop.stop}`, lat: null, long: null, provider: 'KMB' };
                }
                const details = await detailsResponse.json();
                return {
                    stop: stop.stop,
                    name_en: details.data?.name_en || `Stop ${stop.stop}`,
                    lat: details.data?.lat,
                    long: details.data?.long,
                    provider: 'KMB'
                };
            } catch (error) {
                console.warn(`Error fetching KMB stop details for ${stop.stop}:`, error);
                return { stop: stop.stop, name_en: `Stop ${stop.stop}`, lat: null, long: null, provider: 'KMB' };
            }
        }));
        allStops = allStops.concat(kmbStops);
        console.log('KMB stops fetched:', kmbStops.length);
    }

    function getUniqueMTRStations() {
        const stationSet = new Set();
        const stations = [];
        for (let line in lines) {
            lines[line].forEach(station => {
                if (!stationSet.has(station.value)) {
                    stationSet.add(station.value);
                    stations.push({
                        value: station.value,
                        text: station.text,
                        type: 'MTR'
                    });
                }
            });
        }
        return stations;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const Δφ = (lat2 - lat1) * Math.PI / 180;
        const Δλ = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                  Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    function findNearbyStops(targetStop) {
        return allStops.filter(stop => 
            stop.lat && stop.long && 
            haversineDistance(targetStop.lat, targetStop.long, stop.lat, stop.long) <= 1000
        );
    }

    function findBusRoutes(startStopId, endStopId) {
        const startStop = allStops.find(s => s.stop === startStopId);
        const endStop = allStops.find(s => s.stop === endStopId);
        const routeDiv = document.getElementById('route');
        if (!startStop || !endStop) {
            routeDiv.innerHTML = '<p>Invalid bus stops selected.</p>';
            return;
        }

        const startStops = findNearbyStops(startStop);
        const endStops = findNearbyStops(endStop);
        const startStopIds = startStops.map(s => s.stop);
        const endStopIds = endStops.map(s => s.stop);

        const directRoutes = [];

        for (const route of allRoutes) {
            const direction = route.provider === 'KMB' ? (route.direction === 'outbound' ? 'O' : 'I') : route.direction;
            const key = `${route.route}-${route.direction}`;
            const stops = routeStopsMap[key] || [];
            const startMatches = stops.filter(id => startStopIds.includes(id));
            const endMatches = stops.filter(id => endStopIds.includes(id));
            if (startMatches.length > 0 && endMatches.length > 0) {
                let closestStartStop = null, minStartDistance = Infinity;
                for (const stopId of startMatches) {
                    const stop = allStops.find(s => s.stop === stopId);
                    const distance = haversineDistance(startStop.lat, startStop.long, stop.lat, stop.long);
                    if (distance < minStartDistance) {
                        minStartDistance = distance;
                        closestStartStop = stopId;
                    }
                }
                const startIndex = stops.indexOf(closestStartStop);
                const possibleEndStops = endMatches.filter(id => stops.indexOf(id) > startIndex);
                if (possibleEndStops.length > 0) {
                    let closestEndStop = null, minEndDistance = Infinity;
                    for (const stopId of possibleEndStops) {
                        const stop = allStops.find(s => s.stop === stopId);
                        const distance = haversineDistance(endStop.lat, endStop.long, stop.lat, stop.long);
                        if (distance < minEndDistance) {
                            minEndDistance = distance;
                            closestEndStop = stopId;
                        }
                    }
                    const stopDetails = stops.map(id => {
                        const stop = allStops.find(s => s.stop === id);
                        return { id, name: stop ? stop.name_en : `Stop ${id}`, provider: route.provider };
                    });
                    directRoutes.push({
                        route: route.route,
                        direction: route.direction,
                        stops: stopDetails,
                        boardingStop: closestStartStop,
                        alightingStop: closestEndStop,
                        boardingDistance: minStartDistance,
                        alightingDistance: minEndDistance,
                        provider: route.provider
                    });
                }
            }
        }

        if (directRoutes.length > 0) {
            routeDiv.innerHTML = '<h3>Direct Bus Routes</h3>' + renderDirectBusRoutes(directRoutes);
        } else {
            routeDiv.innerHTML = '<p>No direct bus routes found between the selected stops.</p>';
        }
    }

    function renderDirectBusRoutes(routes) {
        return routes.map((route, index) => {
            const boardingStop = allStops.find(s => s.stop === route.boardingStop);
            const alightingStop = allStops.find(s => s.stop === route.alightingStop);
            const boardingName = boardingStop ? boardingStop.name_en : `Stop ${route.boardingStop}`;
            const alightingName = alightingStop ? alightingStop.name_en : `Stop ${route.alightingStop}`;
            const numStops = route.stops.findIndex(s => s.id === route.alightingStop) - 
                            route.stops.findIndex(s => s.id === route.boardingStop);
            const summary = `
                <div 
                    class="route-option" 
                    id="route-summary-${index}" 
                    data-route="${route.route}" 
                    data-direction="${route.direction}" 
                    data-boarding-stop="${route.boardingStop}" 
                    data-provider="${route.provider}"
                    onclick="toggleRouteDetails('route-details-${index}', this)"
                >
                    <strong>Route ${route.route} (${route.provider})</strong> - ${numStops} stops<br>
                    Walk ${Math.round(route.boardingDistance)}m to ${boardingName}, alight at ${alightingName} (${Math.round(route.alightingDistance)}m)
                </div>
            `;
            let details = `<div class="route-details" id="route-details-${index}">`;
            details += '<ul class="stop-list">';
            route.stops.forEach(stop => {
                const className = stop.id === route.boardingStop ? 'boarding-stop' : 
                                stop.id === route.alightingStop ? 'alighting-stop' : '';
                const etaSpan = stop.id === route.boardingStop ? `<span id="eta-${index}"></span>` : '';
                details += `<li class="${className}">${stop.name}${etaSpan}</li>`;
            });
            details += '</ul></div>';
            return summary + details;
        }).join('');
    }

    function toggleRouteDetails(detailsId, summaryElement) {
        const detailsDiv = document.getElementById(detailsId);
        if (detailsDiv.style.display === 'none' || !detailsDiv.style.display) {
            detailsDiv.style.display = 'block';
            const route = summaryElement.getAttribute('data-route');
            const direction = summaryElement.getAttribute('data-direction');
            const boardingStop = summaryElement.getAttribute('data-boarding-stop');
            const provider = summaryElement.getAttribute('data-provider');
            fetchETA(route, direction, boardingStop, provider, detailsId);
        } else {
            detailsDiv.style.display = 'none';
        }
    }

    async function fetchETA(route, direction, stopId, provider, detailsId) {
        const etaSpan = document.querySelector(`#${detailsId} .boarding-stop span`);
        if (!etaSpan) return;

        try {
            let url;
            if (provider === 'CTB') {
                url = `https://rt.data.gov.hk/v2/transport/citybus/eta/CTB/${stopId}/${route}`;
            } else if (provider === 'KMB') {
                url = `https://data.etabus.gov.hk/v1/transport/kmb/stop-eta/${stopId}`;
            } else {
                etaSpan.textContent = ` (ETA unavailable: Unknown provider)`;
                return;
            }

            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            if (provider === 'CTB') {
                const dirMapping = { "outbound": "O", "inbound": "I" };
                const eta = data.data.find(e => e.eta_seq === 1 && e.dir === dirMapping[direction]) || 
                            data.data.find(e => e.eta_seq === 1);
                if (eta && eta.eta) {
                    const minutesLeft = Math.round((new Date(eta.eta) - new Date(eta.data_timestamp)) / 60000);
                    etaSpan.textContent = minutesLeft >= 0 ? ` (ETA: ${minutesLeft} min)` : ` (Due now)`;
                } else {
                    etaSpan.textContent = ` (No ETA)`;
                }
            } else if (provider === 'KMB') {
                const eta = data.data.find(e => e.route === route && e.dir === (direction === 'outbound' ? 'O' : 'I') && e.seq === 1);
                if (eta && eta.eta) {
                    const minutesLeft = Math.round((new Date(eta.eta) - new Date()) / 60000);
                    etaSpan.textContent = minutesLeft >= 0 ? ` (ETA: ${minutesLeft} min)` : ` (Due now)`;
                } else {
                    etaSpan.textContent = ` (No ETA)`;
                }
            }
        } catch (error) {
            etaSpan.textContent = ` (ETA unavailable)`;
            console.error(`ETA fetch failed for ${route} (${provider}) at ${stopId}:`, error);
        }
    }

    function makeSearchable(inputId, optionsId, options) {
        const input = document.getElementById(inputId);
        const optionsContainer = document.getElementById(optionsId);

        input.addEventListener('input', function() {
            const filter = input.value.toLowerCase();
            optionsContainer.innerHTML = '';
            const filteredOptions = options.filter(option => 
                option.text.toLowerCase().includes(filter)
            );
            filteredOptions.forEach(option => {
                const div = document.createElement('div');
                div.textContent = `${option.text} (${option.type})`;
                div.addEventListener('click', function() {
                    input.value = option.text;
                    input.dataset.value = option.value;
                    input.dataset.type = option.type;
                    optionsContainer.style.display = 'none';
                });
                optionsContainer.appendChild(div);
            });
            optionsContainer.style.display = filteredOptions.length > 0 ? 'block' : 'none';
        });

        input.addEventListener('focus', function() {
            optionsContainer.style.display = 'block';
        });

        document.addEventListener('click', function(event) {
            if (!input.contains(event.target) && !optionsContainer.contains(event.target)) {
                optionsContainer.style.display = 'none';
            }
        });
    }

    document.getElementById('swapStations').addEventListener('click', function() {
        const currentInput = document.getElementById('currentStationInput');
        const destinationInput = document.getElementById('destinationStationInput');

        const tempValue = currentInput.value;
        const tempDataValue = currentInput.dataset.value;
        const tempDataType = currentInput.dataset.type;

        currentInput.value = destinationInput.value;
        currentInput.dataset.value = destinationInput.dataset.value || '';
        currentInput.dataset.type = destinationInput.dataset.type || '';

        destinationInput.value = tempValue;
        destinationInput.dataset.value = tempDataValue || '';
        destinationInput.dataset.type = tempDataType || '';
    });

    document.getElementById('routeForm').addEventListener('submit', function(e) {
        e.preventDefault();
        const currentInput = document.getElementById('currentStationInput');
        const destinationInput = document.getElementById('destinationStationInput');
        const currentType = currentInput.dataset.type;
        const destinationType = destinationInput.dataset.type;
        const currentId = currentInput.dataset.value;
        const destinationId = destinationInput.dataset.value;

        const routeDiv = document.getElementById('route');
        routeDiv.innerHTML = '';

        if (!currentId || !destinationId) {
            alert("Please select both a starting and destination station.");
            return;
        }

        if (currentType === 'MTR' && destinationType === 'MTR') {
            window.location.href = `/general_schedule.html?currentStation=${currentId}&destinationStation=${destinationId}`;
        } else if (currentType === 'Bus' && destinationType === 'MTR') {
            localStorage.setItem('allRoutes', JSON.stringify(allRoutes));
            localStorage.setItem('allStops', JSON.stringify(allStops));
            localStorage.setItem('routeStopsMap', JSON.stringify(routeStopsMap));
            window.location.href = `/general_schedule.html?startBusStop=${currentId}&destinationStation=${destinationId}`;
        } else if (currentType === 'MTR' && destinationType === 'Bus') {
            localStorage.setItem('allRoutes', JSON.stringify(allRoutes));
            localStorage.setItem('allStops', JSON.stringify(allStops));
            localStorage.setItem('routeStopsMap', JSON.stringify(routeStopsMap));
            window.location.href = `/general_schedule.html?currentStation=${currentId}&endBusStop=${destinationId}`;
        } else if (currentType === 'Bus' && destinationType === 'Bus') {
            findBusRoutes(currentId, destinationId);
        }
    });

    async function initializeData() {
        const loadingDiv = document.getElementById('loading');
        loadingDiv.style.display = 'block';
        try {
            if (allRoutes.length === 0 || allStops.length === 0) {
                loadingDiv.textContent = 'No bus data available. Some features may not work.';
            } else {
                loadingDiv.style.display = 'none';
            }
        } catch (error) {
            loadingDiv.textContent = 'Error loading bus data. Check console for details.';
            console.error('Initialization failed:', error);
        }
    }
</script>